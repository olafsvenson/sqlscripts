<!DOCTYPE html>
<!-- saved from url=(0068)https://documentation.red-gate.com/sm/analysis-graph/list-of-metrics -->
<html lang="en" style="" class="js rgba backgroundsize opacity cssanimations csstransforms csstransforms3d csstransitions generatedcontent video audio svg inlinesvg smil"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
        
        <meta http-equiv="X-UA-Compatible" content="IE=edge">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <title>List of metrics - SQL Monitor 9 - Product Documentation</title>
      
                <script src="./List of metrics - SQL Monitor 9 - Product Documentation_files/conversations-embed.js.Без названия" type="text/javascript" id="hubspot-messages-loader" data-loader="hs-scriptloader" data-hsjs-portal="305265" data-hsjs-env="prod"></script><script src="./List of metrics - SQL Monitor 9 - Product Documentation_files/305265.js.Без названия" type="text/javascript" id="hs-script-loader"></script><script type="text/javascript" async="" src="./List of metrics - SQL Monitor 9 - Product Documentation_files/munchkin.js.Без названия"></script><script id="twitter-wjs" src="./List of metrics - SQL Monitor 9 - Product Documentation_files/widgets.js.Без названия"></script><script type="text/javascript" async="" src="./List of metrics - SQL Monitor 9 - Product Documentation_files/insight.min.js.Без названия"></script><script id="hs-analytics" src="./List of metrics - SQL Monitor 9 - Product Documentation_files/305265.js(1).Без названия"></script><script async="" src="./List of metrics - SQL Monitor 9 - Product Documentation_files/analytics.js.Без названия"></script><script>
window.WRM=window.WRM||{};window.WRM._unparsedData=window.WRM._unparsedData||{};window.WRM._unparsedErrors=window.WRM._unparsedErrors||{};
WRM._unparsedData["com.atlassian.plugins.atlassian-plugins-webresource-plugin:context-path.context-path"]="\u0022\u0022";
if(window.WRM._dataArrived)window.WRM._dataArrived();</script>
<link type="text/css" rel="stylesheet" href="./List of metrics - SQL Monitor 9 - Product Documentation_files/batch.css" data-wrm-key="_super" data-wrm-batch-type="context" media="all">
<!--[if lt IE 9]>
<link type="text/css" rel="stylesheet" href="/s/272b754c409cb6f6ed4585ce0f8cc921-CDN/ru_RU/8100/a516614738a0811691ee4368be900fdd7a640552/2d3b9a004cb6f1f0017712aae9a05dc9/_/download/contextbatch/css/_super/batch.css?conditionalComment=lt+IE+9" data-wrm-key="_super" data-wrm-batch-type="context" media="all">
<![endif]-->
<!--[if lte IE 9]>
<link type="text/css" rel="stylesheet" href="/s/272b754c409cb6f6ed4585ce0f8cc921-CDN/ru_RU/8100/a516614738a0811691ee4368be900fdd7a640552/2d3b9a004cb6f1f0017712aae9a05dc9/_/download/contextbatch/css/_super/batch.css?conditionalComment=lte+IE+9" data-wrm-key="_super" data-wrm-batch-type="context" media="all">
<![endif]-->

      
                <link rel="stylesheet" href="./List of metrics - SQL Monitor 9 - Product Documentation_files/honeycomb.css">
        <link rel="stylesheet" href="./List of metrics - SQL Monitor 9 - Product Documentation_files/redgate.confluence.css">    
      
        <script>
			var contextPath = '';
      	   	var pageId = '67535219';
    		var commentResourcePath = '/plugins/servlet/scroll-viewport/comment';
		</script>
      
                
                
                <script>
window.WRM=window.WRM||{};window.WRM._unparsedData=window.WRM._unparsedData||{};window.WRM._unparsedErrors=window.WRM._unparsedErrors||{};
WRM._unparsedData["com.atlassian.plugins.atlassian-plugins-webresource-plugin:context-path.context-path"]="\u0022\u0022";
if(window.WRM._dataArrived)window.WRM._dataArrived();</script>
<script type="text/javascript" src="./List of metrics - SQL Monitor 9 - Product Documentation_files/batch.js.Без названия" data-wrm-key="_super" data-wrm-batch-type="context"></script>
<script type="text/javascript" src="./List of metrics - SQL Monitor 9 - Product Documentation_files/com.k15t.scroll.scroll-viewport_resource-editor-resource-omitter.js.Без названия" data-wrm-key="com.k15t.scroll.scroll-viewport:resource-editor-resource-omitter" data-wrm-batch-type="resource"></script>


                <script src="./List of metrics - SQL Monitor 9 - Product Documentation_files/modernizr.min.js.Без названия"></script>
        <link rel="stylesheet" type="text/css" href="./List of metrics - SQL Monitor 9 - Product Documentation_files/prettify.css">

                <!-- Begin Gooogle Analytics -->
<script>
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','https://www.google-analytics.com/analytics.js','ga');

  ga('create', 'UA-90206-130', 'auto');
  ga('send', 'pageview');

</script>
<!-- End Gooogle Analytics -->

<!-- Begin Async HubSpot Analytics Code tracking for Tom Lewin -->
<script type="text/javascript">
(function(d,s,i,r) {
  if (d.getElementById(i)){return;}
  var n=d.createElement(s),e=d.getElementsByTagName(s)[0];
  n.id=i;n.src='//js.hs-analytics.net/analytics/'+(Math.ceil(new Date()/r)*r)+'/305265.js';
  e.parentNode.insertBefore(n, e);
})(document,"script","hs-analytics",300000);
</script>
<!-- End Async HubSpot Analytics Code tracking -->

<!-- Begin LinkedIn Lead Accelerator -->
<script type="text/javascript">
	_bizo_data_partner_id = "8524";
	(function() {
		var s = document.getElementsByTagName("script")[0];
		var b = document.createElement("script");
		b.type = "text/javascript";
		b.async = true;
		b.src = (window.location.protocol === "https:" ? "https://sjs" : "http://js") + ".bizographics.com/insight.min.js";
		s.parentNode.insertBefore(b, s);
	})();
</script>
<noscript>
	<img height="1" width="1" alt="" style="display:none;" src="//www.bizographics.com/collect/?pid=8524&fmt=gif" />
</noscript>
<!-- End LinkedIn Lead Accelerator -->
 
      
                      
      
                
     
    <script type="text/javascript" async="" src="./List of metrics - SQL Monitor 9 - Product Documentation_files/munchkin.js(1).Без названия"></script><style type="text/css">.fancybox-margin{margin-right:17px;}</style></head>

    <body class="sm9" itemscope="" itemtype="http://schema.org/WebPage" data-aui-version="7.9.7"><style type="text/css">html.hs-messages-widget-open.hs-messages-mobile,html.hs-messages-widget-open.hs-messages-mobile body{overflow:hidden!important;position:relative!important}html.hs-messages-widget-open.hs-messages-mobile body{height:100%!important;margin:0!important}#hubspot-messages-iframe-container{display:initial!important;z-index:2147483647;position:fixed!important;bottom:0!important}#hubspot-messages-iframe-container.widget-align-left{left:0!important}#hubspot-messages-iframe-container.widget-align-right{right:0!important}#hubspot-messages-iframe-container.internal{z-index:1016}#hubspot-messages-iframe-container.internal iframe{min-width:108px}#hubspot-messages-iframe-container .shadow-container{display:initial!important;z-index:-1;position:absolute;width:0;height:0;bottom:0;content:""}#hubspot-messages-iframe-container .shadow-container.internal{display:none!important}#hubspot-messages-iframe-container .shadow-container.active{width:400px;height:400px}#hubspot-messages-iframe-container iframe{display:initial!important;width:100%!important;height:100%!important;border:none!important;position:absolute!important;bottom:0!important;right:0!important;background:transparent!important}</style>

        <div class="band header--primary">
            <nav>
                <a href="https://www.red-gate.com/" class="header--primary__app-logo-container">
                    <img src="./List of metrics - SQL Monitor 9 - Product Documentation_files/redgate-logo--white.svg" class="js-svg" width="94" alt="">
                </a>

                <a href="https://documentation.red-gate.com/home" class="header--primary__app-name-container">
                    Documentation
                </a>
              
              	<ul>
                  <li><a href="https://documentation.red-gate.com/home">All Products</a></li>
                  <li><a href="https://productsupport.red-gate.com/">Support</a></li>
                  <li><a href="https://forum.red-gate.com/">Forums</a></li>
                </ul>

                <span class="float-right hide-on-medium">
                    <!-- <ul>
                        <li><a href="https://documentation.red-gate.com/">Documentation Home</a></li>
                    </ul> -->
                  
                  	


<!-- Confluence search form -->
<form action="https://documentation.red-gate.com/sm/search" method="GET" id="search" class="header--primary__search-form">
  <input id="search-input" type="text" size="100" autocomplete="on" placeholder="Search ..." name="q" value="">
  <input type="hidden" name="s" value="SM9">
  <button type="submit">Search</button>
</form>

<!-- Redgate.com global search form
<form action="https://www.red-gate.com/Search/" method="GET" id="search" class="header--primary__search-form">
  <input id="search-input" type="text" size="100" autocomplete="on" placeholder="Search ..." name="s">
  <input type="hidden" name="t" value="support">
  <button type="submit">Search</button>
</form> -->
                </span>
            </nav>
        </div>
 

<section class="band background-color--grey--1 space-header">
  <div class="band__inner-container">  
    <div class="media">
      <img src="./List of metrics - SQL Monitor 9 - Product Documentation_files/SM9" class="media__image space-header__logo">
      <div class="media__body">
        <h1 class="beta text--redgate spaced-bottom--none">SQL Monitor 9</h1>
        
        <div class="media">        
                    <p class="media__image media__image--right spaced-bottom--none hide-on-medium js-older-versions" style="display: block;">Help for <a href="https://documentation.red-gate.com/sm9/release-notes-and-other-versions">older versions</a> available.</p>
          <div class="media__body">
            <ul class="breadcrumbs list--bare list--horizontal">
      <li><a href="https://documentation.red-gate.com/sm">SQL Monitor 9 documentation</a></li>           
      <li><a href="https://documentation.red-gate.com/sm/analysis-graph">Analysis graph</a></li>           
    <li>List of metrics</li>
</ul>
          </div>
        </div>

      </div>
    </div>
    
  </div>
</section>

<section class="band content-container">
    <div class="band__inner-container band__inner-container--tight grid padded-v--none">

                <div class="grid__col grid__col--span-3-of-12">
			<div class="confluence-sidebar">
	<nav class="nav--vertical nav--vertical--minimal" style="min-height: 37041px;">
      <ul data-viewport-id="AC1F284C016D25F1C59AFB0C0C1612CC" data-root="/sm" data-current="/sm/analysis-graph/list-of-metrics"><li class="collapsed"><a href="https://documentation.red-gate.com/sm/getting-started" class=""><span class="nav--vertical__toggle nav--vertical__toggle--has-children"></span>Getting started</a></li><li class="collapsed"><a href="https://documentation.red-gate.com/sm/configuring-sql-monitor" class=""><span class="nav--vertical__toggle nav--vertical__toggle--has-children"></span>Configuring SQL Monitor</a></li><li class="leaf"><a href="https://documentation.red-gate.com/sm/global-dashboard" class="">Global dashboard</a></li><li class="collapsed"><a href="https://documentation.red-gate.com/sm/overview-pages" class=""><span class="nav--vertical__toggle nav--vertical__toggle--has-children"></span>Overview pages</a></li><li class="collapsed"><a href="https://documentation.red-gate.com/sm/alerts" class=""><span class="nav--vertical__toggle nav--vertical__toggle--has-children"></span>Alerts</a></li><li class="nav--vertical__active-parent"><a href="https://documentation.red-gate.com/sm/analysis-graph" class="nav--vertical__active-parent"><span class="nav--vertical__toggle nav--vertical__toggle--has-children"></span>Analysis graph</a><ul class="nav"><li class="leaf"><a href="https://documentation.red-gate.com/sm/analysis-graph/displaying-metrics-on-the-analysis-graph" class="">Displaying metrics on the analysis graph</a></li><li class="leaf"><a href="https://documentation.red-gate.com/sm/analysis-graph/using-a-baseline-for-comparison" class="">Using a baseline for comparison</a></li><li class="leaf"><a href="https://documentation.red-gate.com/sm/analysis-graph/finding-additional-metric-information" class="">Finding additional metric information</a></li><li class="nav--vertical__active leaf"><a href="https://documentation.red-gate.com/sm/analysis-graph/list-of-metrics" class="nav--vertical__active">List of metrics</a></li></ul></li><li class="collapsed"><a href="https://documentation.red-gate.com/sm/reports" class=""><span class="nav--vertical__toggle nav--vertical__toggle--has-children"></span>Reports</a></li><li class="collapsed"><a href="https://documentation.red-gate.com/sm/estate" class=""><span class="nav--vertical__toggle nav--vertical__toggle--has-children"></span>Estate</a></li><li class="collapsed"><a href="https://documentation.red-gate.com/sm/advanced-operations" class=""><span class="nav--vertical__toggle nav--vertical__toggle--has-children"></span>Advanced operations</a></li><li class="collapsed"><a href="https://documentation.red-gate.com/sm/troubleshooting" class=""><span class="nav--vertical__toggle nav--vertical__toggle--has-children"></span>Troubleshooting</a></li><li class="collapsed"><a href="https://documentation.red-gate.com/sm/release-notes-and-other-versions" class=""><span class="nav--vertical__toggle nav--vertical__toggle--has-children"></span>Release notes and other versions</a></li><li class="leaf"><a href="https://documentation.red-gate.com/sm/how-to-articles" class="">How-to articles</a></li><li class="collapsed"><a href="https://documentation.red-gate.com/sm/api" class=""><span class="nav--vertical__toggle nav--vertical__toggle--has-children"></span>API</a></li></ul>
  </nav>
</div>
        </div>
      
      	        <div class="grid__col grid__col--span-8-of-12 grid__col--push-1-of-12 page-content">
          	<div class="padded-top">
              <h1 class="spaced-bottom--none">List of metrics</h1>
              <p class="page__metadata" itemprop="dateModified" datetime="2018-03-08">Last updated 08 March 2018, viewed 488 times</p>
              <p class="visually-hidden" itemprop="datePublished" datetime="2018-03-08">Published 08 March 2018</p>

              

    <div class="grid__row grid__row--confluence conf-macro output-block" data-hasbody="true" data-macro-name="sp-pagelayout">
            <div class="grid__col grid__col--span-8-of-12">
            <h2 id="Listofmetrics-Machinemetrics">Machine metrics</h2><h3 id="Listofmetrics-Machine:processortime"><span>Machine: processor time</span></h3><p><span style="color: rgb(68,68,68);">Total processor utilization (averaged across all processor cores) on the physical host Windows machine.</span></p><div class="table-wrap"><table style="line-height: 1.42857;" class="confluenceTable"><tbody><tr><td class="confluenceTd">Equivalent PerfMon counter</td><td class="confluenceTd"><span style="color: rgb(68,68,68);">Processor: % Processor Time (_Total)</span></td></tr><tr><td class="confluenceTd">Explanation</td><td class="confluenceTd"><span style="color: rgb(68,68,68);">This is a general indicator of how busy all of your processors are. Each data point represents the average non-idle time for all processor cores since the previous data point; average utilization for each processor is totaled and then divided by the number of processors on the machine.&nbsp;</span><strong>Machine: processor time</strong><span style="color: rgb(68,68,68);">&nbsp;is collected and averaged every 15 seconds.</span></td></tr><tr><td class="confluenceTd">Guideline values</td><td class="confluenceTd"><p><span style="color: rgb(68,68,68);">Ideally,&nbsp;</span><strong>Machine: processor time</strong><span style="color: rgb(68,68,68);">&nbsp;should average less than 50% for best SQL Server performance. If&nbsp;</span><strong>Machine: processor time</strong><span style="color: rgb(68,68,68);">&nbsp;exceeds an average 80% for a sustained time (five minutes or more), then a CPU bottleneck exists during this time, and you should investigate its cause. Keep in mind that short spikes in&nbsp;</span><strong>Machine: processor time</strong><span style="color: rgb(68,68,68);">&nbsp;above 80% are normal and expected, and only sustained high CPU utilization is a problem. If a spike indicates a plateau, not a sharp peak, this may indicate a slow running query is causing the CPU problem.</span></p><p><span style="color: rgb(68,68,68);"><span style="color: rgb(68,68,68);">Note: When running in a virtual environment, the&nbsp;</span><strong>Machine: processor time</strong><span style="color: rgb(68,68,68);">&nbsp;is not relevant because it is unable to accurately measure the CPU activity within a virtual machine. Instead, use the Hyper-V Logical Processor performance counters.</span></span></p></td></tr><tr><td colspan="1" class="confluenceTd">Check also</td><td colspan="1" class="confluenceTd"><ul style="margin-left: 1.0em;"><li><strong>SQL Server processor time:</strong>&nbsp;In most dedicated SQL Server machines, there is a high correlation between&nbsp;<strong>Machine: processor time</strong>&nbsp;and&nbsp;<strong>SQL Server: processor time</strong>. If the&nbsp;<strong>Machine: processor time</strong>&nbsp;is much higher than the&nbsp;<strong>SQL Server: processor time</strong>, then some process, other than SQL Server is causing the high CPU utilization, and this process should be investigated.</li><li><strong>Avg. CPU queue length:</strong><span style="color: rgb(68,68,68);">&nbsp;This measures the number of threads in the processor queue. There is a single queue for processor time even on computers with multiple cores. If a computer has multiple processor cores, SQL Monitor divides this value by the number of processor cores servicing the workload. A sustained processor queue of less than 10 threads per processor is normally acceptable, dependent of the workload. A number exceeding 10 threads per processor indicates a potential CPU bottleneck.</span></li></ul></td></tr><tr><td colspan="1" class="confluenceTd">Possible solutions</td><td colspan="1" class="confluenceTd"><p><span style="color: rgb(68,68,68);">Assuming the&nbsp;</span><strong>Machine: processor time</strong><span style="color: rgb(68,68,68);">&nbsp;is due to the SQL Server process, reducing CPU utilization can be accomplished many different ways, including rewriting poorly written queries, reducing query plan recompilation, optimizing query parallelism, and avoiding using client-side cursors. If correcting the above does not resolve CPU bottlenecks, consider upgrading to faster processors or increasing the number of processors.</span></p><p><span style="color: rgb(68,68,68);"><span style="color: rgb(68,68,68);">If the&nbsp;</span><strong>Machine: processor time</strong><span style="color: rgb(68,68,68);">&nbsp;is high, and the&nbsp;</span><strong>SQL Server: processor time</strong><span style="color: rgb(68,68,68);">&nbsp;is not highly correlated, then identify the non-SQL Server process causing the excessive CPU activity and correct it.</span></span></p></td></tr><tr><td colspan="1" class="confluenceTd">More information</td><td colspan="1" class="confluenceTd"><p><a rel="nofollow" class="external-link" href="http://sqlcat.com/whitepapers/archive/2008/10/03/running-sql-server-2008-in-a-hyper-v-environment-best-practices-and-performance-recommendations.aspx">Running SQL Server 2008 in a Hyper-V Environment</a></p><p><a rel="nofollow" class="external-link" href="http://msdn.microsoft.com/en-us/windows/hardware/gg463394">Performance Tuning Guidelines for Windows Server 2008</a></p><p><a rel="nofollow" class="external-link" href="http://msdn.microsoft.com/en-us/library/dd672789.aspx">Troubleshooting Performance Problems in SQL Server 2008</a></p></td></tr></tbody></table></div><h3 id="Listofmetrics-Avg.CPUqueuelength">Avg. CPU queue length</h3><p><span style="color: rgb(68,68,68);">Measures the number of threads in the processor queue waiting to be executed. The queue contains threads that are ready to run but cannot because all of the processor cores are busy.</span></p><div class="table-wrap"><table class="confluenceTable"><tbody><tr><td class="confluenceTd">Equivalent PerfMon counter</td><td class="confluenceTd"><span style="color: rgb(68,68,68);">System: Processor Queue Length (divided by the number of processor cores)</span></td></tr><tr><td class="confluenceTd">Explanation</td><td class="confluenceTd"><span style="color: rgb(68,68,68);">There is a single process queue, even on computers with multiple cores. Therefore, if a computer has multiple processor cores, SQL Monitor automatically divides the processor queue length by the number of processor cores servicing the workload to determine the average processor queue length.</span></td></tr><tr><td class="confluenceTd">Guideline values</td><td class="confluenceTd"><p><span style="color: rgb(68,68,68);">The lower the number, the better, but an average processor queue length of less than 10 is normally acceptable, dependent on the workload. A number exceeding 10 threads per processor indicates a CPU bottleneck. Occasional spikes in the average processor queue length over 10 are normal, but only sustained spikes in the average processor queue length are a problem.</span></p></td></tr><tr><td colspan="1" class="confluenceTd">Check also</td><td colspan="1" class="confluenceTd"><p><strong>Machine: processor time</strong>&nbsp;for the host machine. If the average process queue length is regularly greater than 10, and<strong>Machine: processor time</strong>&nbsp;regularly exceeds 80%, then your machine has a CPU bottleneck.</p></td></tr><tr><td colspan="1" class="confluenceTd">Possible solutions</td><td colspan="1" class="confluenceTd"><p><span style="color: rgb(68,68,68);">If a CPU bottleneck is confirmed, reducing CPU utilization can be accomplished in many different ways, including rewriting poorly written queries, reducing query plan recompilation, optimizing query parallelism, and avoiding using client-side cursors. If correcting the above does not resolve CPU bottlenecks, consider upgrading to faster processors or increasing the number of processors. If the&nbsp;</span><strong>Machine: processor time</strong><span style="color: rgb(68,68,68);">&nbsp;is high, and the&nbsp;</span><strong>SQL Server: processor time</strong><span style="color: rgb(68,68,68);">&nbsp;is not highly correlated, then identify the non-SQL Server process causing the excessive CPU activity and correct it.</span></p></td></tr><tr><td colspan="1" class="confluenceTd">More information</td><td colspan="1" class="confluenceTd"><p><a rel="nofollow" class="external-link" href="http://msdn.microsoft.com/en-us/library/dd672789.aspx">Troubleshooting Performance Problems in SQL Server 2008</a></p></td></tr></tbody></table></div><h3 id="Listofmetrics-Machine:memoryused">Machine: memory used</h3><p><span style="color: rgb(68,68,68);">Displays the amount of physical memory (in bytes) used on the server.</span></p><div class="table-wrap"><table class="confluenceTable"><tbody><tr><td class="confluenceTd">Equivalent PerfMon counter</td><td class="confluenceTd"><span style="color: rgb(68,68,68);">(WMI: Win32_ComputerSystem.TotalPhysicalMemory) - (Memory: Available Bytes)</span></td></tr><tr><td class="confluenceTd">Explanation</td><td class="confluenceTd"><span style="color: rgb(68,68,68);">This is the total number of bytes of memory currently used by all processes. If applications on the server are running slow, and data access is also slow, you may want to check the values for this metric.</span></td></tr><tr><td class="confluenceTd">Guideline values</td><td class="confluenceTd"><p><span style="color: rgb(68,68,68);">High values may suggest a computer memory shortage or indicate that the computer or an application is not releasing memory. The optimal value depends on how much physical memory the machine has. For example, on a 6 GB machine, you may allow 2 GB for your operating system and assign the remaining RAM to your SQL Server.</span></p></td></tr><tr><td colspan="1" class="confluenceTd">Check also</td><td colspan="1" class="confluenceTd"><p><strong>Memory pages/sec</strong><span style="color: rgb(68,68,68);">. This indicates whether memory shortages may be caused by excessive paging.</span></p></td></tr></tbody></table></div><h3 id="Listofmetrics-Memorypages/sec">Memory pages/sec</h3><p><span style="color: rgb(68,68,68);">Measures the rate at which pages are read from or written to disk to resolve page faults.</span></p><div class="table-wrap"><table class="confluenceTable"><tbody><tr><td class="confluenceTd">Equivalent PerfMon counter</td><td class="confluenceTd"><span style="color: rgb(68,68,68);">Memory: Pages/sec</span></td></tr><tr><td class="confluenceTd">Explanation</td><td class="confluenceTd"><span style="color: rgb(68,68,68);">This is the sum of the memory pages input/sec and memory pages output/sec. It highlights the number of pages that were retrieved from disk because of hard page faults, or were written to disk to free space in the working set because of page faults.</span></td></tr><tr><td class="confluenceTd">Guideline values</td><td class="confluenceTd"><p><span style="color: rgb(68,68,68);">Extreme variations in&nbsp;</span><strong>Memory pages/sec</strong><span style="color: rgb(68,68,68);">&nbsp;are very common, especially when operations such as backups, restores, imports, or exports are performed. If&nbsp;</span><strong>Memory pages/sec</strong><span style="color: rgb(68,68,68);">&nbsp;exceeds 1000, and if the number of bytes available is less than 100 MB on a consistent basis, this is a strong indication of memory pressure.</span></p></td></tr><tr><td colspan="1" class="confluenceTd">Check also</td><td colspan="1" class="confluenceTd"><p><strong>Machine: memory used</strong><span style="color: rgb(68,68,68);">&nbsp;and PerfMon counter&nbsp;</span><strong>Process: working set</strong><span style="color: rgb(68,68,68);">&nbsp;to calculate the amount of physical RAM available to SQL Server that is not currently being used by other processes. If the number of bytes available is less than 100 MB, and</span><strong>Memory pages/sec</strong><span style="color: rgb(68,68,68);">&nbsp;are high, the server is under significant memory pressure.</span></p></td></tr><tr><td colspan="1" class="confluenceTd">Possible solutions</td><td colspan="1" class="confluenceTd"><span style="color: rgb(68,68,68);">Remove unnecessary applications and services from your server, add more physical RAM.</span></td></tr></tbody></table></div><h3 id="Listofmetrics-Networkutilization">Network utilization</h3><p><span style="color: rgb(68,68,68);">The percentage of total bandwidth usage to help identify whether your network adapter is at saturation point.</span></p><div class="table-wrap"><table class="confluenceTable"><tbody><tr><td class="confluenceTd">Equivalent PerfMon counter</td><td class="confluenceTd"><span style="color: rgb(68,68,68);">8 * ((Network Interface: Bytes Received/sec) + (Network Interface: Bytes Sent/sec)) / (Network Interface: Current Bandwidth) *100</span></td></tr><tr><td class="confluenceTd">Explanation</td><td class="confluenceTd"><span style="color: rgb(68,68,68);">Indicates the total amount of bandwidth being used on the connection to which the network card is attached. It is useful to determine when the network is idle, normal or busy. Note: This does not measure the amount of bandwidth being sent to and from the server. The value is calculated by adding together the rates at which bytes are sent and received per second over the network adapter and then converting them to bits. This value is then compared with the current bandwidth on the network adapter to calculate&nbsp;</span><strong>Network utilization</strong><span style="color: rgb(68,68,68);">.</span></td></tr><tr><td class="confluenceTd">Guideline values</td><td class="confluenceTd"><p><span style="color: rgb(68,68,68);">This value is most useful when there is a single SQL Server instance on a host machine with no other network traffic. The ideal percentage value depends on the type of network connection you are using, so a baseline should be set against which efficiency can be measured. On average, more than 50% network utilization is high and more than 80% network utilization is very high. For optimum performance, you should have a network connection to a dedicated switch port running at full duplex.</span></p></td></tr><tr><td colspan="1" class="confluenceTd">Check also</td><td colspan="1" class="confluenceTd"><p><span style="color: rgb(68,68,68);">During busy periods, further investigation into the network-related processes running at the time may reveal which ones are placing significant load on network bandwidth. To do this, open Windows Task Manager and select Resource Monitor from the Performance tab.</span></p></td></tr><tr><td colspan="1" class="confluenceTd">Possible solutions</td><td colspan="1" class="confluenceTd"><span style="color: rgb(68,68,68);">Turn off power savings mode on network cards, manually set the speed and duplex of your network card instead of having it set automatically for you, use a faster network card, add additional network cards.</span></td></tr></tbody></table></div><h3 id="Listofmetrics-Diskused">Disk used</h3><p><span style="color: rgb(68,68,68);">The amount of space used for each disk (in GB).</span></p><div class="table-wrap"><table class="confluenceTable"><tbody><tr><td class="confluenceTd">Equivalent PerfMon counter</td><td class="confluenceTd"><span style="color: rgb(68,68,68);">((denominator of LogicalDisk: % Free Space) - (LogicalDisk: Free Megabytes))</span></td></tr><tr><td class="confluenceTd">Explanation</td><td class="confluenceTd"><span style="color: rgb(68,68,68);">This information allows you to monitor how much storage space is being used and how much is available on each disk. It is important to evaluate the adequacy of your system's disk space to avoid programs failing because the system is unable to allocate space, and to prevent constraints on the growth of page filing to support virtual memory.</span></td></tr><tr><td class="confluenceTd">Guideline values</td><td class="confluenceTd"><p><span style="color: rgb(68,68,68);"><span style="color: rgb(68,68,68);">The amount of disk capacity you need to ensure your system disks are adequately supported can be calculated as follows:</span></span></p><ol style="margin-left: 1.0em;"><li>Allow 1 GB for an operating system.</li><li>Add the size of all applications.</li><li>Add at least twice the size of system memory for the paging file.</li><li>Add the disk space estimate for each user multiplied by the number of users.</li><li>Multiply by at least 130% to take into account room for expansion.</li></ol><p><span style="color: rgb(68,68,68);">As a general rule, if the disk space used is 80% of capacity or greater, you may consider running a Disk Cleanup tool, compressing or defragmenting the disk, transferring certain files to other disks or using remote storage.</span></p></td></tr></tbody></table></div><h3 id="Listofmetrics-Diskavg.readtime">Disk avg. read time</h3><p><span style="color: rgb(68,68,68);">T<span style="color: rgb(68,68,68);">he average time in milliseconds of a read operation from the logical disk.</span></span></p><div class="table-wrap"><table class="confluenceTable"><tbody><tr><td class="confluenceTd">Equivalent PerfMon counter</td><td class="confluenceTd"><span style="color: rgb(68,68,68);">Logical Disk: Avg. Disk sec/Read</span></td></tr><tr><td class="confluenceTd">Explanation</td><td class="confluenceTd"><span style="color: rgb(68,68,68);">Measures logical disk latency (how fast a disk responds) when data is read from it. The lower the latency, the faster the I/O performance, and vice versa. This metric, and the&nbsp;</span><strong>Disk avg. write time</strong><span style="color: rgb(68,68,68);">&nbsp;metric, are two of the most important indicators of I/O bottlenecks.</span></td></tr><tr><td class="confluenceTd">Guideline values</td><td class="confluenceTd"><p><span style="color: rgb(68,68,68);">For drives with MDF and NDF files and OLTP loads, average read latency should ideally be below 20 ms. For drives with OLAP loads, then latency up to 30 ms is considered acceptable. For drives with LDF files, latency should ideally be 5 ms or less. In general, anything above 50 ms is slow and suggests a potentially serious I/O bottleneck. Write latency will vary considerably over time, so these guideline figures ignore occasional spikes.</span></p></td></tr><tr><td colspan="1" class="confluenceTd">Check also</td><td colspan="1" class="confluenceTd"><p><strong>Disk avg. write time</strong><span style="color: rgb(68,68,68);">. The values should correspond with the guidelines described above.</span></p></td></tr><tr><td colspan="1" class="confluenceTd">Possible solutions</td><td colspan="1" class="confluenceTd"><span style="color: rgb(68,68,68);">Tune queries to reduce the resources used to execute them, use faster disk drives, use RAID 10, use more spindles inside RAID arrays, use faster controllers, use multiple controllers, use short-stroking, avoid using SANs where your data files are shared on arrays with other applications. MDF and NDF files should always be isolated from LDF files. Ideally, each LDF file should be on its own array for maximum performance.</span></td></tr></tbody></table></div><h3 id="Listofmetrics-Diskavg.writetime">Disk avg. write time</h3><p><span style="color: rgb(68,68,68);">T<span style="color: rgb(68,68,68);">he average time, in milliseconds, of a write of data from the logical disk.</span></span></p><div class="table-wrap"><table class="confluenceTable"><tbody><tr><td class="confluenceTd">Equivalent PerfMon counter</td><td class="confluenceTd"><span style="color: rgb(68,68,68);">Logical Disk: Avg. Disk sec/Write</span></td></tr><tr><td class="confluenceTd">Explanation</td><td class="confluenceTd"><span style="color: rgb(68,68,68);">Measures logical disk latency (how fast a disk responds) when data is written to it. The lower the latency, the faster the I/O performance, and vice versa. This metric, and the Disk avg. read/sec metric, are two of the most important indicators of I/O bottlenecks.</span></td></tr><tr><td class="confluenceTd">Guideline values</td><td class="confluenceTd"><p><span style="color: rgb(68,68,68);">For drives with MDF and NDF files and OLTP loads, average write latency should ideally be below 20 ms. For drives with OLAP loads, then latency up to 30 ms is considered acceptable. For drives with LDF files, latency should ideally be 5 ms or less. In general, anything above 50 ms is slow and suggests a potentially serious I/O bottleneck. Write latency will vary considerably over time, so these guideline figures ignore occasional spikes.</span></p></td></tr><tr><td colspan="1" class="confluenceTd">Check also</td><td colspan="1" class="confluenceTd"><p><strong>Disk avg. read time</strong><span style="color: rgb(68,68,68);">. The values should correspond with the guidelines described above.</span></p></td></tr><tr><td colspan="1" class="confluenceTd">Possible solutions</td><td colspan="1" class="confluenceTd"><span style="color: rgb(68,68,68);">Tune queries to reduce the resources used to execute them, use faster disk drives, use RAID 10, use more spindles inside RAID arrays, use faster controllers, use multiple controllers, use short-stroking, avoid using SANs where your data files are shared on arrays with other applications. MDF and NDF files should always be isolated from LDF files. Ideally, each LDF file should be on its own array for maximum performance.</span></td></tr></tbody></table></div><h3 id="Listofmetrics-Disktransfers/sec">Disk transfers/sec</h3><p><span style="color: rgb(68,68,68);">Measures how many read and write requests are being completed per second on the logical disk.</span></p><div class="table-wrap"><table class="confluenceTable"><tbody><tr><td class="confluenceTd">Equivalent PerfMon counter</td><td class="confluenceTd"><span style="color: rgb(68,68,68);">Logical Disk: Disk Transfers/sec</span></td></tr><tr><td class="confluenceTd">Explanation</td><td class="confluenceTd"><span style="color: rgb(68,68,68);">This metric helps to determine the number of IOPS (IOs per second) occurring on the logical disk, and whether your SQL Server applications are creating more I/O that can be handled by the disk subsystem.</span></td></tr><tr><td class="confluenceTd">Guideline values</td><td class="confluenceTd"><p><span style="color: rgb(68,68,68);">The Disk Transfers/sec should not exceed the IOPS capacity of your disk subsystem, otherwise there will be an I/O bottleneck.</span></p></td></tr><tr><td colspan="1" class="confluenceTd">Check also</td><td colspan="1" class="confluenceTd"><p><strong>Disk avg. read time</strong><span style="color: rgb(68,68,68);">&nbsp;and&nbsp;</span><strong>Disk avg. write time</strong><span style="color: rgb(68,68,68);">. If these metrics are not within their recommended thresholds, then most likely your disk subsystem does not have the IOPS capacity it needs to keep up with the current application workload.</span></p></td></tr><tr><td colspan="1" class="confluenceTd">Possible solutions</td><td colspan="1" class="confluenceTd"><span style="color: rgb(68,68,68);">The first thing you should do is determine the IOPS capacity of your disk system. Once you know what it is, then you will be in a position to know if you need to do anything to help boost the IOPS capacity of your disk subsystem, such as tune queries to reduce the resources used to execute them, use faster disk drives, use RAID 10, use more spindles inside RAID arrays, use faster controllers, use multiple controllers, use short-stroking, avoid using SANs where your data files are shared on arrays with other applications. MDF and NDF files should always be isolated from LDF files. Ideally, each LDF file should be on its own array for maximum performance.</span></td></tr><tr><td colspan="1" class="confluenceTd">More information</td><td colspan="1" class="confluenceTd"><a rel="nofollow" class="external-link" href="http://blogs.technet.com/b/cotw/archive/2009/03/18/analyzing-storage-performance.aspx">Analyzing Storage Performance</a></td></tr></tbody></table></div><h3 id="Listofmetrics-Avg.diskqueuelength">Avg. disk queue length</h3><p><span style="color: rgb(68,68,68);">Measures the pressure on the physical hard disk array.</span></p><div class="table-wrap"><table class="confluenceTable"><tbody><tr><td class="confluenceTd">Equivalent PerfMon counter</td><td class="confluenceTd"><span style="color: rgb(68,68,68);">Logical Disk: Avg. Disk Queue Length</span></td></tr><tr><td class="confluenceTd">Explanation</td><td class="confluenceTd"><span style="color: rgb(68,68,68);">This is the average number of physical read and write requests queued for a physical disk.</span></td></tr><tr><td class="confluenceTd">Guideline values</td><td class="confluenceTd"><p><span style="color: rgb(68,68,68);">Due to changes in technology, such as virtualization, disk and controller technology, SANs and more, this counter is no longer a good indicator of I/O bottlenecks. A better measure of I/O bottlenecks is&nbsp;</span><strong>Avg. disk read time</strong><span style="color: rgb(68,68,68);">&nbsp;and&nbsp;</span><strong>Avg. disk write time</strong><span style="color: rgb(68,68,68);">.</span></p></td></tr><tr><td colspan="1" class="confluenceTd">Check also</td><td colspan="1" class="confluenceTd"><p><strong>Disk avg. read time</strong><span style="color: rgb(68,68,68);">&nbsp;and&nbsp;</span><strong>Disk avg. write time</strong><span style="color: rgb(68,68,68);">.</span></p></td></tr></tbody></table></div><h2 id="Listofmetrics-SQLServermetrics">SQL Server metrics</h2><h3 id="Listofmetrics-Userconnections">User connections</h3><p><span style="color: rgb(68,68,68);">The total number of user connections to a SQL Server instance at a given time.</span></p><div class="table-wrap"><table class="confluenceTable"><tbody><tr><td class="confluenceTd">Equivalent PerfMon counter</td><td class="confluenceTd"><span style="color: rgb(68,68,68);">SQLServer: General Statistics: User Connections</span></td></tr><tr><td class="confluenceTd">Explanation</td><td class="confluenceTd"><p><span style="color: rgb(68,68,68);">This value provides a general guideline of how busy the SQL Server is. Every connection to a SQL Server instance requires on average 28 KB of memory overhead, even if the user is not currently using the connection. You can adjust the settings for your SQL Server instance so that the maximum number of user connections permitted is determined automatically by identifying the number of users currently logged on.</span></p><p><span style="color: rgb(68,68,68);"><span style="color: rgb(68,68,68);">Generally speaking, there is a correlation between the number of user connections and&nbsp;</span><strong>Batch requests/sec</strong><span style="color: rgb(68,68,68);">.</span></span></p><p><span style="color: rgb(68,68,68);"><span style="color: rgb(68,68,68);"><span style="color: rgb(68,68,68);">Note: The user connections value is not the same as the number of users. A single user may have multiple connections open, or multiple users may share a single connection.</span></span></span></p></td></tr><tr><td class="confluenceTd">Guideline values</td><td class="confluenceTd"><p><span style="color: rgb(68,68,68);">It is useful to monitor this value over time to indicate increases or decreases in usage of your SQL Server. The number of worker threads is calculated dynamically based on the type of installation and number of processors available to SQL Server:</span></p><p><span style="color: rgb(68,68,68);">&nbsp;</span></p><ul style="margin-left: 1.0em;"><li>For 32-bit servers, the base worker thread count is 256 and 8 additional worker threads are added for each scheduler above the initial 4 on the server ((NumberOfSchedulers -4) *8) +256.</li><li>For 64-bit servers, the base worker thread count is 512 and 16 additional worker threads are added for each scheduler above the initial 4 on the server ((NumberOfSchedulers -4) *16) +512.</li></ul><p><span style="color: rgb(68,68,68);">For more information on worker thread counts, see&nbsp;</span><a rel="nofollow" class="external-link" href="http://msdn.microsoft.com/en-us/library/ms190219.aspx">Configure the max worker threads Server Configuration Option</a><span style="color: rgb(68,68,68);">.</span></p><p><span style="color: rgb(68,68,68);">&nbsp;</span><span style="color: rgb(68,68,68);">Note: The number of connections on a server can easily be three or four times the number of worker threads if connection pooling is being used. Connections are pooled per application domain, per connection string, per server, and not every connection will be executing at exactly the same time.</span></p></td></tr></tbody></table></div><h3 id="Listofmetrics-SQLServer:processortime">SQL Server: processor time</h3><p><span style="color: rgb(68,68,68);">The processor utilization (%) for the SQL Server service running on the host Windows machine.</span></p><div class="table-wrap"><table class="confluenceTable"><tbody><tr><td class="confluenceTd">Equivalent PerfMon counter</td><td class="confluenceTd"><span style="color: rgb(68,68,68);">Process(sqlservr): % Processor Time</span></td></tr><tr><td class="confluenceTd">Explanation</td><td class="confluenceTd"><p><span style="color: rgb(68,68,68);">This value tells you what percentage of processor time is being used to run the sqlservr process (the database engine). It excludes other SQL Server-related processes, such as the SQL Server Agent, SSIS, Reporting Services, Analysis Services, and Full Text Search. Because&nbsp;</span><strong>SQL Server: processor time</strong><span style="color: rgb(68,68,68);">&nbsp;is a subset of&nbsp;</span><strong>Machine: processor time</strong><span style="color: rgb(68,68,68);">, the&nbsp;</span><strong>SQL Server: processor time</strong><span style="color: rgb(68,68,68);">&nbsp;value will be lower.</span></p><p><span style="color: rgb(68,68,68);"><span style="color: rgb(68,68,68);">Note: On multiprocessor computers, it is common for SQL Server to use more than the equivalent of 100% processor time on one processor. This is because its threads may be using multiple processors.</span></span></p></td></tr><tr><td class="confluenceTd">Guideline values</td><td class="confluenceTd"><p><span style="color: rgb(68,68,68);">Ideally,&nbsp;</span><strong>SQL Server: processor time</strong><span style="color: rgb(68,68,68);">&nbsp;should average less than 50% for best SQL Server performance. If it exceeds an average 80% for a sustained time (five minutes or more), then a CPU bottleneck exists during this time, and you should investigate its cause. Short spikes in&nbsp;</span><strong>SQL Server: processor time</strong><span style="color: rgb(68,68,68);">&nbsp;above 80% are normal and expected, and only sustained high CPU utilization is a problem. If a spike indicates a plateau, not a sharp peak, this may indicate a slow running query is causing the CPU problem.</span></p><p><span style="color: rgb(68,68,68);"><span style="color: rgb(68,68,68);">Generally,&nbsp;</span><strong>SQL Server: processor time</strong><span style="color: rgb(68,68,68);">&nbsp;should be the busiest process on a host system, and will correlate closely with&nbsp;</span><strong>Machine: processor time</strong><span style="color: rgb(68,68,68);">. If&nbsp;</span><strong>SQL Server: processor time</strong><span style="color: rgb(68,68,68);">&nbsp;is substantially smaller than&nbsp;</span><strong>Machine: processor time</strong><span style="color: rgb(68,68,68);">, this may indicate that some other process running on the host system is using CPU, potentially using CPU resources that could be used by the Database Engine in order to enhance its performance. If this is the case, identify which processes are using Task Manager in order to diagnose what is happening on your host system.</span></span></p></td></tr><tr><td colspan="1" class="confluenceTd">Check also</td><td colspan="1" class="confluenceTd"><p><strong>Machine: processer time</strong><span style="color: rgb(68,68,68);">&nbsp;where the average utilization for each processor is totaled and then divided by the number of processors on the machine. If this average is 80% or more, or if you consistently record averages greater than 50%, your processors may need upgrading. Also,&nbsp;</span><strong>Avg. CPU queue length</strong><span style="color: rgb(68,68,68);">&nbsp;provides a stronger indication of whether your processor is running slowly.</span></p></td></tr></tbody></table></div><h3 id="Listofmetrics-SQLServer:totalmemory">SQL Server: total memory</h3><p><span style="color: rgb(68,68,68);">The total amount of dynamic memory the server is currently using.</span></p><div class="table-wrap"><table class="confluenceTable"><tbody><tr><td class="confluenceTd">Equivalent PerfMon counter</td><td class="confluenceTd"><span style="color: rgb(68,68,68);">SQLServer:Memory Manager - Total Server Memory (KB)</span></td></tr><tr><td class="confluenceTd">Explanation</td><td class="confluenceTd"><span style="color: rgb(68,68,68);">Amount of physical memory the mssqlserver service is currently using; includes the total of the buffers committed to the SQL Server BPool and "OS in Use" type buffers.</span></td></tr><tr><td class="confluenceTd">Guideline values</td><td class="confluenceTd"><p><span style="color: rgb(68,68,68);">If&nbsp;</span><strong>SQL Server: total memory</strong><span style="color: rgb(68,68,68);">&nbsp;is relatively high compared to the amount of physical memory in the computer, it may indicate that more physical memory is required.</span></p></td></tr><tr><td colspan="1" class="confluenceTd">Check also</td><td colspan="1" class="confluenceTd"><ul style="margin-left: 1.0em;"><li><strong>SQL Server: target memory:</strong>&nbsp;Displays the maximum amount of dynamic memory (the buffer pool) that SQL Server is prepared to use. This number cannot exceed the maximum server memory setting. When SQL Server first starts, this value corresponds to the buffers reserved at SQL Server startup. The default memory management behavior of the Microsoft SQL Server Database Engine is to acquire as much memory as it needs without creating a memory shortage on the system. If SQL Server needs more physical RAM after startup, and if there are Mbytes available, then SQL Server will grab it and&nbsp;<strong>SQL Server: target memory</strong>&nbsp;will increase. If the OS requests RAM back from SQL Server, then&nbsp;<strong>SQL Server: target memory</strong>&nbsp;will usually decrease, which in some cases can cause SQL Server memory pressure, hurting SQL Server performance.</li><li><strong>Buffer cache hit ratio:</strong>&nbsp;The percentage of pages that were found in the buffer cache without having to read from disk. Ideally, this value should be close to 99% for OLTP system. A smaller number may indicate that the SQL Server is under memory pressure. OLAP systems often have a Buffer Cache Hit Ratio of less than 90%, which is typical.</li><li><strong>Buffer free pages:</strong>&nbsp;The number of free spaces available in the buffer cache. Generally speaking, if this number drops below 640 pages, this could indicate SQL Server memory pressure.</li><li><strong>Buffer page life expectancy:</strong>&nbsp;Measures the average number of seconds a page will stay in the buffer cache without being accessed. Generally speaking, if his value drops below 300 seconds, this may indicate SQL Server is under memory pressure.</li></ul></td></tr><tr><td colspan="1" class="confluenceTd">Possible solutions</td><td colspan="1" class="confluenceTd"><span style="color: rgb(68,68,68);">Remove unnecessary applications and services from your server, and add more physical RAM.</span></td></tr></tbody></table></div><h3 id="Listofmetrics-SQLServer:targetmemory">SQL Server: target memory</h3><p><span style="color: rgb(68,68,68);">Maximum amount of dynamic memory (the buffer pool) that SQL Server is prepared to use.</span></p><div class="table-wrap"><table class="confluenceTable"><tbody><tr><td class="confluenceTd">Equivalent PerfMon counter</td><td class="confluenceTd"><span style="color: rgb(68,68,68);">SQLServer:Memory Manager - Target Server Memory (KB)</span></td></tr><tr><td class="confluenceTd">Explanation</td><td class="confluenceTd"><span style="color: rgb(68,68,68);">Displays the maximum amount of dynamic memory (the buffer pool) that SQL Server is prepared to use. This value cannot exceed the max server memory setting. When SQL Server first starts, this value corresponds to the buffers reserved at SQL Server startup. The default memory management behavior of the Microsoft SQL Server Database Engine is to acquire as much memory as it needs without creating a memory shortage on the system. If SQL Server needs more physical RAM after startup, and if Mbytes are available, then SQL Server will grab it and&nbsp;</span><strong>SQL Server: target memory</strong><span style="color: rgb(68,68,68);">&nbsp;will increase. If the OS requests RAM back from SQL Server, then&nbsp;</span><strong>SQL Server: target memory</strong><span style="color: rgb(68,68,68);">&nbsp;will usually decrease, which in some cases can cause SQL Server memory pressure, hurting SQL Server's performance.</span></td></tr><tr><td class="confluenceTd">Guideline values</td><td class="confluenceTd"><p><span style="color: rgb(68,68,68);">If this value is high (relative to the total physical memory available on your machine), then you should consider adding extra physical memory, to improve the performance of SQL Server.</span></p></td></tr><tr><td colspan="1" class="confluenceTd">Check also</td><td colspan="1" class="confluenceTd"><ul style="margin-left: 1.0em;"><li><strong>SQL Server: total memory:</strong>&nbsp;Displays the total amount of dynamic memory (the buffer pool) the server is currently using.&nbsp;<strong>SQL Server: total memory</strong>&nbsp;will increase as SQL Server needs it, assuming it is available. This value will always be smaller or equal to&nbsp;<strong>SQL Server: target memory</strong>. If&nbsp;<strong>SQL Server: total memory</strong>&nbsp;is relatively high compared to the amount of physical memory in the computer, it may indicate that more physical memory is required.</li><li><strong>Buffer cache hit ratio:</strong>&nbsp;The percentage of pages that were found in the buffer cache without having to read from disk. Ideally, this value should be close to 99% for OLTP system. A smaller number may indicate that the SQL Server is under memory pressure. OLAP systems often have a Buffer cache hit ratio of less than 90%, which is typical.</li><li><strong>Buffer free pages:</strong>&nbsp;The number of free spaces available in the buffer cache. If this number drops below 640 pages, this could indicate SQL Server is under memory pressure.</li><li><strong>Buffer page life expectancy:</strong>&nbsp;Measures the average number of seconds a page will stay in the buffer cache without being accessed. If his value drops below 300 seconds, this may indicate SQL Server is under memory pressure.</li></ul></td></tr><tr><td colspan="1" class="confluenceTd">Possible solutions</td><td colspan="1" class="confluenceTd"><span style="color: rgb(68,68,68);">Remove unnecessary applications and services from your server, and add more physical RAM.</span></td></tr></tbody></table></div><h3 id="Listofmetrics-SQLServer:freememory">SQL Server: free memory</h3><p><span style="color: rgb(68,68,68);">The total amount of dynamic memory that the server is not using.</span></p><p><span style="color: rgb(68,68,68);"><strong>Note</strong><span style="color: rgb(68,68,68);">: This metric was introduced in SQL Server 2012 to replace&nbsp;</span><strong>Buffer free pages</strong><span style="color: rgb(68,68,68);">&nbsp;(which was used in SQL Server 2008 and earlier). For SQL Server 2008 and earlier, we've now converted free pages into memory (1 page is equal to 8 KB).</span></span></p><div class="table-wrap"><table class="confluenceTable"><tbody><tr><td class="confluenceTd">Equivalent PerfMon counter</td><td class="confluenceTd"><span style="color: rgb(68,68,68);">SQLServer: Memory Manager - Free memory</span></td></tr><tr><td class="confluenceTd">Explanation</td><td class="confluenceTd"><span style="color: rgb(68,68,68);">The Memory Manager monitors the overall memory usage of SQL Server. This metric can help you identify whether there are bottlenecks resulting from a lack of memory (which means that SQL Server has to retrieve data from disk). It can also help you to identify whether you can improve query performance by increasing the amount of memory.</span></td></tr><tr><td class="confluenceTd">Guideline values</td><td class="confluenceTd"><p><span style="color: rgb(68,68,68);">A&nbsp;</span><strong>free memory</strong><span style="color: rgb(68,68,68);">&nbsp;value greater than 5 MB should ensure that the buffer cache can handle sufficient new memory allocation requests. A value less than 5 MB may mean that requests are stalled and this can affect performance. You may consider adding memory or making more memory available to the data cache.</span></p></td></tr><tr><td colspan="1" class="confluenceTd">Check also</td><td colspan="1" class="confluenceTd"><p><strong>Buffer cache hit ratio</strong><span style="color: rgb(68,68,68);">: If this value is below 90% and your&nbsp;</span><strong>free memory</strong><span style="color: rgb(68,68,68);">&nbsp;value is less than 5 MB, you may be experiencing memory pressure and additional RAM may be required.</span></p></td></tr></tbody></table></div><h3 id="Listofmetrics-Batchrequests/sec">Batch requests/sec</h3><p><span style="color: rgb(68,68,68);">Number of T-SQL batch requests received by SQL Server per second, averaged since last collection time.</span></p><div class="table-wrap"><table class="confluenceTable"><tbody><tr><td class="confluenceTd">Equivalent PerfMon counter</td><td class="confluenceTd"><span style="color: rgb(68,68,68);">SQLServer:SQL Statistics - Batch Requests/sec</span></td></tr><tr><td class="confluenceTd">Explanation</td><td class="confluenceTd"><p><span style="color: rgb(68,68,68);">This gives a general indicator of how busy SQL Server is. It measures all of the batches you send to the SQL Server. The number of batch requests SQL Server can handle is dependent on the capability of your hardware. It may be useful to track this value over time, to gauge the scalability of your system, and to identify when you have peaks and troughs in user requests.</span></p><p><span style="color: rgb(68,68,68);"><strong>Batch requests/sec</strong><span style="color: rgb(68,68,68);">&nbsp;only tracks the number of batches, not the statements in the batch. Some batches may use very little resources, while other batches use huge amounts of resources. Each batch is different, and this metric only provides an absolute count of the batches executed by SQL Server.</span></span></p></td></tr><tr><td class="confluenceTd">Guideline values</td><td class="confluenceTd"><p><span style="color: rgb(68,68,68);">In general, over 1000 batch requests per second indicates a very busy SQL Server, and could highlight the potential for a CPU bottleneck. More powerful hardware can of course handle higher numbers of requests.</span></p></td></tr><tr><td colspan="1" class="confluenceTd">Check also</td><td colspan="1" class="confluenceTd"><p><strong>Compilations/batch</strong><span style="color: rgb(68,68,68);">&nbsp;and&nbsp;</span><strong>Compilations/sec</strong><span style="color: rgb(68,68,68);">. These values should be as low as possible, as high values may indicate a lot of ad-hoc queries being run. You may need to optimize T-SQL.</span></p></td></tr></tbody></table></div><h3 id="Listofmetrics-Compilations/sec">Compilations/sec</h3><p><span style="color: rgb(68,68,68);">SQL compilations per second; each data point shows the average value since the previous data point.</span></p><div class="table-wrap"><table class="confluenceTable"><tbody><tr><td class="confluenceTd">Equivalent PerfMon counter</td><td class="confluenceTd"><span style="color: rgb(68,68,68);">SQLServer:SQL Statistics - SQL Compilations/sec</span></td></tr><tr><td class="confluenceTd">Explanation</td><td class="confluenceTd"><p><span style="color: rgb(68,68,68);">The number of times that Transact-SQL compilations occur, per second (including recompiles). The lower the value the better. Each compilation uses CPU and other resources, so SQL Server will attempt to reuse cached execution plans wherever possible. Not having to recompile the stored procedure reduces the overhead on the server and speeds up overall performance.</span></p></td></tr><tr><td class="confluenceTd">Guideline values</td><td class="confluenceTd"><p><span style="color: rgb(68,68,68);">In general,&nbsp;</span><strong>Compilations/sec</strong><span style="color: rgb(68,68,68);">&nbsp;should be less than 10% of the&nbsp;</span><strong>Batch requests/sec</strong><span style="color: rgb(68,68,68);">. High values often indicate excessive ad-hoc querying and should be as low as possible.</span></p></td></tr><tr><td colspan="1" class="confluenceTd">Check also</td><td colspan="1" class="confluenceTd"><p><strong>Batch requests/sec</strong><span style="color: rgb(68,68,68);">.</span></p></td></tr><tr><td colspan="1" class="confluenceTd">Possible solutions</td><td colspan="1" class="confluenceTd"><span style="color: rgb(68,68,68);">Rewrite ad-hoc queries as stored procedures. Reduce usage of temp tables, or combine statements to eliminate them in stored procedures. Check "SET" statements - changes in session settings such as ANSI_PADDING or ANSI_NULLS can cause a query to be recompiled. If SQL Compilations/sec are excessive in SQL Server 2005 or later, consider using "Forced parameterization" on the database. This tells SQL Server to force the parameterization of virtually all SELECT, INSERT, UPDATE and DELETE statements, requiring fewer compilations of statements due to re-use of more query plans.</span></td></tr></tbody></table></div><h3 id="Listofmetrics-Compilations/batch">Compilations/batch</h3><p><span style="color: rgb(68,68,68);">SQL compilations per batch requests received by SQL Server.</span></p><div class="table-wrap"><table class="confluenceTable"><tbody><tr><td class="confluenceTd">Equivalent PerfMon counter</td><td class="confluenceTd"><span style="color: rgb(68,68,68);">(SQLServer:SQL Statistics - SQL Compilations/sec) / (SQLServer:SQL Statistics - Batch Requests/sec)</span></td></tr><tr><td class="confluenceTd">Explanation</td><td class="confluenceTd"><p><span style="color: rgb(68,68,68);">This should provide a general indication of how quickly and efficiently SQL Server query optimizer is processing user queries.</span></p></td></tr><tr><td class="confluenceTd">Guideline values</td><td class="confluenceTd"><p><span style="color: rgb(68,68,68);">As a general rule,&nbsp;</span><strong>Compilations/sec</strong><span style="color: rgb(68,68,68);">&nbsp;should be less than 10% of the&nbsp;</span><strong>Batch requests/sec</strong><span style="color: rgb(68,68,68);">. High values often indicate excessive adhoc querying and should be as low as possible.</span></p></td></tr><tr><td colspan="1" class="confluenceTd">Check also</td><td colspan="1" class="confluenceTd"><p><strong>Compilations/sec</strong><span style="color: rgb(68,68,68);">&nbsp;and&nbsp;</span><strong>Batch requests/sec</strong><span style="color: rgb(68,68,68);">.</span></p></td></tr></tbody></table></div><h3 id="Listofmetrics-Recompilations/sec">Recompilations/sec</h3><p><span style="color: rgb(68,68,68);">Number of times, per second, that Transact-SQL objects attempted to be executed had to be recompiled.</span></p><div class="table-wrap"><table class="confluenceTable"><tbody><tr><td class="confluenceTd">Equivalent PerfMon counter</td><td class="confluenceTd"><span style="color: rgb(68,68,68);">SQLServer:SQL Statistics - Re-Compilations/sec</span></td></tr><tr><td class="confluenceTd">Explanation</td><td class="confluenceTd"><p><span style="color: rgb(68,68,68);">Usually, once an object is compiled, it does not have to be recompiled. When a stored procedure or query is recompiled, a compile lock is placed on the objects referenced by the procedure, and database blocking may occur. Excessive recompilations can cause serious performance problems or may compile locks that are incompatible with any known locking type.</span></p></td></tr><tr><td class="confluenceTd">Guideline values</td><td class="confluenceTd"><p><strong>Recompilations/sec</strong><span style="color: rgb(68,68,68);">&nbsp;should be as small as possible. Any value greater than 10% of&nbsp;</span><strong>Compilations/sec</strong><span style="color: rgb(68,68,68);">&nbsp;can indicate a problem.</span></p></td></tr><tr><td colspan="1" class="confluenceTd">Check also</td><td colspan="1" class="confluenceTd"><p><strong>Compilations/sec</strong><span style="color: rgb(68,68,68);">,&nbsp;</span><strong>Batch requests/sec</strong><span style="color: rgb(68,68,68);">, and&nbsp;</span><strong>Compilations/batch requests</strong><span style="color: rgb(68,68,68);">&nbsp;to determine how quickly and efficiently SQL Server and the query optimizer are processing user queries. Check also SP:Recompile and SQL:StmtRecompile event classes in a Profiler trace to identify which stored procedures and SQL statements need recompiling with every run. The EventSubClass data column tells you what caused the recompile.</span></p></td></tr></tbody></table></div><h3 id="Listofmetrics-Buffercachehitratio">Buffer cache hit ratio</h3><p><span style="color: rgb(68,68,68);">The percentage of pages that were found in the buffer pool without having to read from disk.</span></p><div class="table-wrap"><table class="confluenceTable"><tbody><tr><td class="confluenceTd">Equivalent PerfMon counter</td><td class="confluenceTd"><span style="color: rgb(68,68,68);">SQLServer: Buffer Manager - Buffer cache hit ratio</span></td></tr><tr><td class="confluenceTd">Explanation</td><td class="confluenceTd"><p><span style="color: rgb(68,68,68);">Indicates how frequently a query gets information from cache instead of accessing the hard disk. The value is calculated by dividing the total number of cache hits by the total number of cache lookups. This figure is an average value calculated since the SQL Server service was last restarted, not a snapshot of what is currently happening on your server now. Because of this, be careful how you interpret this value.</span></p></td></tr><tr><td class="confluenceTd">Guideline values</td><td class="confluenceTd"><p><span style="color: rgb(68,68,68);">If your server is running online transaction processing (OLTP) applications, a value of 99% or higher is ideal, but anything above 90% is generally considered satisfactory. A value of 90% or lower may indicate increased I/O access and slower performance. Adding more physical RAM may help alleviate this problem.</span></p><p><span style="color: rgb(68,68,68);"><span style="color: rgb(68,68,68);">If your server is running online analytical processing (OLAP) applications, it is not uncharacteristic for this value to fall below 90%, which is not normally a problem, unless you see other signs of memory pressure.</span></span></p><p><span style="color: rgb(68,68,68);"><span style="color: rgb(68,68,68);"><span style="color: rgb(68,68,68);">Note: Be aware that the value of this metric immediately after a service restart will be uncharacteristically low until enough time has passed for the data cache to fill.</span></span></span></p></td></tr><tr><td colspan="1" class="confluenceTd">Check also</td><td colspan="1" class="confluenceTd"><p><strong>Buffer page life expectancy:</strong><span style="color: rgb(68,68,68);">&nbsp;Measures the average number of seconds a page will stay in the buffer cache without being accessed. Generally, if his value drops below 300 seconds, this may indicate SQL Server is under memory pressure.</span></p></td></tr></tbody></table></div><h3 id="Listofmetrics-Bufferpagelifeexpectancy">Buffer page life expectancy</h3><p><span style="color: rgb(68,68,68);">Indicates the average number of seconds a page will stay in the buffer pool without being referenced.</span></p><div class="table-wrap"><table class="confluenceTable"><tbody><tr><td class="confluenceTd">Equivalent PerfMon counter</td><td class="confluenceTd"><span style="color: rgb(68,68,68);">S<span style="color: rgb(68,68,68);">QLServer: Buffer Manager - Page life expectancy</span></span></td></tr><tr><td class="confluenceTd">Explanation</td><td class="confluenceTd"><p><span style="color: rgb(68,68,68);">Data is cached in the buffer pool so that it can be retrieved much faster than having to retrieve it from disk. However, once data pages have been stored in the buffer pool, they may or may not be reused. If a page is not referenced after a given amount of time, that page will be removed from the buffer pool so other data can use the space. A high buffer page life expectancy indicates that buffer pages are being reused often, which in turn indicates that the SQL Server is not under any memory pressure.</span></p></td></tr><tr><td class="confluenceTd">Guideline values</td><td class="confluenceTd"><p><span style="color: rgb(68,68,68);">This value depends on the amount of RAM installed on the servers. It is best practice to record a baseline measurement against which you can compare the monitored values over time. Do this by running the formula (DataCacheSizeInGB/4GB*300) as recommended in&nbsp;</span><a rel="nofollow" class="external-link" href="http://www.red-gate.com/SM5/SQL-skills-plan-cache">Finding what queries in the plan cache use a specific index</a><span style="color: rgb(68,68,68);">. For details on how to find the data cache size, see&nbsp;</span><a rel="nofollow" class="external-link" href="http://www.red-gate.com/SM5/wastedbuffermemory">Performance issues from wasted buffer pool memory</a><span style="color: rgb(68,68,68);">.</span></p><p><span style="color: rgb(68,68,68);"><span style="color: rgb(68,68,68);">If data pages consistently remain in the buffer for less than your baseline value, this may indicate that there is insufficient memory on the system or not enough memory is configured for SQL Server use. You may consider improving performance by adding RAM. The problem may also be caused by missing indexes, poor index design or badly written application code, such as too many stored procedures being recompiled, or queries reading large tables in the buffer pool when only a small number of rows need changing. Addressing application-specific problems may improve performance.</span></span></p></td></tr><tr><td colspan="1" class="confluenceTd">Check also</td><td colspan="1" class="confluenceTd"><p><strong>Buffer cache hit ratio</strong><span style="color: rgb(68,68,68);">. If this value is consistently low or drops suddenly, memory bottleneck may be the most likely cause.</span></p></td></tr></tbody></table></div><h3 id="Listofmetrics-Fullscans/sec">Full scans/sec</h3><p><span style="color: rgb(68,68,68);"><span style="color: rgb(68,68,68);">Measures the number of base table or full index scans occuring per second</span>.</span></p><div class="table-wrap"><table class="confluenceTable"><tbody><tr><td class="confluenceTd">Equivalent PerfMon counter</td><td class="confluenceTd"><span style="color: rgb(68,68,68);">SQLServer:Access Methods: Full Scans/sec</span></td></tr><tr><td class="confluenceTd">Explanation</td><td class="confluenceTd"><p><span style="color: rgb(68,68,68);">This value monitors how many full scans are performed on tables or indexes. While index scans are a normal part of how SQL Server works, a lot of full scans may indicate missing indexes, accessing many small tables, or queries that return large quantities of rows.</span></p></td></tr><tr><td class="confluenceTd">Guideline values</td><td class="confluenceTd"><p><span style="color: rgb(68,68,68);">It is best practice to record a baseline measurement against which you can compare your monitored values. If the monitored value is significantly higher when compared with the baseline, and CPU is also high, it may suggest performance bottleneck. The ratio of Index searches/sec to&nbsp;</span><strong>Full scans/sec</strong><span style="color: rgb(68,68,68);">&nbsp;should generally be no more than 1000:1.</span></p></td></tr><tr><td colspan="1" class="confluenceTd">Check also</td><td colspan="1" class="confluenceTd"><p><strong>Machine: processor time</strong><span style="color: rgb(68,68,68);">&nbsp;to establish whether CPU is also high. Also look at&nbsp;</span><strong>Batch requests/sec</strong><span style="color: rgb(68,68,68);">&nbsp;against your baseline measurement for details of how well the database is coping with queries. You can then check the&nbsp;</span><strong>Lock waits/sec</strong><span style="color: rgb(68,68,68);">&nbsp;and&nbsp;</span><strong>Lock timeouts/sec</strong><span style="color: rgb(68,68,68);">&nbsp;to determine whether locking issues are affecting performance.</span></p></td></tr></tbody></table></div><h3 id="Listofmetrics-Pagesplits/sec">Page splits/sec</h3><p><span style="color: rgb(68,68,68);">The number of page splits, and new page allocations, in a SQL Server table per second.</span></p><div class="table-wrap"><table class="confluenceTable"><tbody><tr><td class="confluenceTd">Equivalent PerfMon counter</td><td class="confluenceTd"><span style="color: rgb(68,68,68);">SQLServer:Access Methods: Page Splits/sec</span></td></tr><tr><td class="confluenceTd">Explanation</td><td class="confluenceTd"><p><span style="color: rgb(68,68,68);">As new data is inserted or added to an existing data page, and the page does not have enough room for all the new data to fit, SQL Server splits the page, leaving half of the data on the old page and putting the other half on a new page. This is a normal SQL Server event, but excessive page splitting can result in index fragmentation and a variety of related performance problems.</span></p></td></tr><tr><td class="confluenceTd">Guideline values</td><td class="confluenceTd"><p><span style="color: rgb(68,68,68);">It is best practice to record a baseline against which you can compare your monitored values. In general terms, this value should not be greater than 20% of the number of&nbsp;</span><strong>Batch requests/sec</strong><span style="color: rgb(68,68,68);">. A low value is preferable, but what constitutes low depends on a number of variable factors including the number of users, the level of user activity and your I/O subsystem performance capabilities.</span></p></td></tr><tr><td colspan="1" class="confluenceTd">Check also</td><td colspan="1" class="confluenceTd"><p><strong>Disk avg. read time</strong><span style="color: rgb(68,68,68);">&nbsp;and&nbsp;</span><strong>Disk avg. write time</strong><span style="color: rgb(68,68,68);">. There is often a correlation between excessive I/O activity and excessive page splitting.</span></p></td></tr><tr><td colspan="1" class="confluenceTd">Possible solutions</td><td colspan="1" class="confluenceTd"><span style="color: rgb(68,68,68);">Resolving page splitting problems is often difficult as the original database design may be contributing to the problem. Besides reconsidering the database design, also consider reevaluating your indexing strategy, and perhaps increase the fillfactor of the indexes being affected by excessive page splitting. If excessive page splitting cannot be effectively eliminated, consider increasing the frequency in which you rebuild or reorganize your indexes in order to remove the fragmentation created by page splitting.</span></td></tr></tbody></table></div><h3 id="Listofmetrics-Pagesplits/batchrequest">Page splits/batch request</h3><p><span style="color: rgb(68,68,68);">The number of page splits per second in a SQL Server table divided by the number of T-SQL command batch requests received per second.</span></p><div class="table-wrap"><table class="confluenceTable"><tbody><tr><td class="confluenceTd">Equivalent PerfMon counter</td><td class="confluenceTd"><span style="color: rgb(68,68,68);">(SQLServer:Access Methods: Page Splits/sec) / (SQLServer:SQL Statistics - Batch Requests/sec)</span></td></tr><tr><td class="confluenceTd">Explanation</td><td class="confluenceTd"><p><span style="color: rgb(68,68,68);">While pages splits are a normal SQL Server function, excessive page splitting can negatively affect SQL Server performance.</span></p></td></tr><tr><td class="confluenceTd">Guideline values</td><td class="confluenceTd"><p><span style="color: rgb(68,68,68);">On average, the number of page splits per batch request should be below 20% of the number of batch requests per second, but ideally as close to 0 as possible.</span></p></td></tr><tr><td colspan="1" class="confluenceTd">Check also</td><td colspan="1" class="confluenceTd"><p><span style="color: rgb(68,68,68);">The fill factor of the tables in your indexes. The lower the fill factor, the more space, which helps reduce potential page splits. For more information about fill factor, see the&nbsp;</span><a rel="nofollow" class="external-link" href="https://msdn.microsoft.com/en-us/library/ms177459.aspx">MSDN documentation</a><span style="color: rgb(68,68,68);">.</span></p></td></tr></tbody></table></div><h3 id="Listofmetrics-Latchwaittime">Latch wait time</h3><p><span style="color: rgb(68,68,68);">T<span style="color: rgb(68,68,68);">he average wait time, in milliseconds, that latch requests have to wait before being executed.</span></span></p><div class="table-wrap"><table class="confluenceTable"><tbody><tr><td class="confluenceTd">Equivalent PerfMon counter</td><td class="confluenceTd"><span style="color: rgb(68,68,68);">SQLServer:Latches - Average Latch Wait Time (ms)</span></td></tr><tr><td class="confluenceTd">Explanation</td><td class="confluenceTd"><p><span style="color: rgb(68,68,68);">Think of a latch as a lightweight lock used by SQL Server to manage many internal operations. They prevent one SQL Server internal operation from conflicting with another internal SQL Server operation. This average is calculated by dividing latch wait milliseconds by the number of latch waits.</span></p><p><span style="color: rgb(68,68,68);"><span style="color: rgb(68,68,68);">Monitoring latch wait time helps to generically identify user activity and resource utilization that may be the cause of performance bottlenecks. The current average should be compared against a baseline average. Note that latches that do not have to wait for requests to be granted are not included in this value.</span></span></p></td></tr><tr><td class="confluenceTd">Guideline values</td><td class="confluenceTd"><p><span style="color: rgb(68,68,68);">In general, there is a correlation between this metric and latch waits/sec. Use PerfMon to check the latch waits/sec value. If both values increase above their baseline averages, the SQL Server is experiencing resource contention that needs further investigation.</span></p></td></tr><tr><td colspan="1" class="confluenceTd">Check also</td><td colspan="1" class="confluenceTd"><p><span style="color: rgb(68,68,68);">the following features included in the dynamic management view (DMV) to help identify which activity is causing latch wait problems:</span></p><p><span style="color: rgb(68,68,68);">&nbsp;</span></p><ul style="margin-left: 1.0em;"><li><em>sys.dm_os_latch_stats</em>&nbsp;(latch wait information by class)</li><li><em>sys.dm_os_wait_stats</em>&nbsp;(details about the waits encountered by threads in execution)</li><li><em>sys.dm_db_index_operational_stats</em>&nbsp;(details of I/O, latching, locking and access method activity for table partitions or database indexes)</li></ul><p><span style="color: rgb(68,68,68);">Note: These DMVs are not supported in SQL 2000. If you are using SQL 2000, use the DBCC SQLPERF('WAITSTATS') statement.</span></p><p><span style="color: rgb(68,68,68);"><span style="color: rgb(68,68,68);">The relative wait numbers and times for every latch class must be reviewed to understand SQL Server instance performance issues.</span></span></p></td></tr></tbody></table></div><h3 id="Listofmetrics-Locktimeouts/sec">Lock timeouts/sec</h3><p><span style="color: rgb(68,68,68);"><span><span style="color: rgb(68,68,68);">The number of locks per second that timed out</span>.</span></span></p><div class="table-wrap"><table class="confluenceTable"><tbody><tr><td class="confluenceTd">Equivalent PerfMon counter</td><td class="confluenceTd"><span style="color: rgb(68,68,68);">S<span style="color: rgb(68,68,68);">QLServer:Locks - Lock Timeouts/sec</span></span></td></tr><tr><td class="confluenceTd">Explanation</td><td class="confluenceTd"><p><span style="color: rgb(68,68,68);">Locks are held on SQL Server resources to stop them from being used simultaneously by another transaction. For example, if a transaction holds an exclusive lock on a row, no other transaction can make changes to that row until the lock is removed. Fewer locks allow more concurrent transactions to take place and this may improve performance.</span></p><p><span style="color: rgb(68,68,68);"><span style="color: rgb(68,68,68);">The lock timeout limit in SQL Server depends on the value set using the SET LOCK_TIMEOUT command. If no value is set, SQL Server will wait indefinitely for the lock to clear.</span></span></p></td></tr><tr><td class="confluenceTd">Guideline values</td><td class="confluenceTd"><p><span style="color: rgb(68,68,68);">Any value greater than 0 suggests that users may be experiencing problems with queries that are not completing.</span></p></td></tr><tr><td colspan="1" class="confluenceTd">Check also</td><td colspan="1" class="confluenceTd"><p><strong>Lock waits/sec</strong><span style="color: rgb(68,68,68);">. This can identify the number of locks that did not timeout but had to wait for resource.</span></p></td></tr></tbody></table></div><h3 id="Listofmetrics-Lockwaits/sec">Lock waits/sec</h3><p><span style="color: rgb(68,68,68);">The number of locks per second that could not be satisfied immediately and had to wait for resources.</span></p><div class="table-wrap"><table class="confluenceTable"><tbody><tr><td class="confluenceTd">Equivalent PerfMon counter</td><td class="confluenceTd"><span style="color: rgb(68,68,68);">SQLServer:Locks - Lock Waits/sec</span></td></tr><tr><td class="confluenceTd">Explanation</td><td class="confluenceTd"><p><span style="color: rgb(68,68,68);">Locks are held on SQL Server resources to stop them from being used simultaneously by another transaction. For example, if a transaction holds an exclusive lock on a row, no other transaction can make changes to that row until the lock is removed. Fewer locks allow more concurrent transactions to take place and this may improve performance.</span></p></td></tr><tr><td class="confluenceTd">Guideline values</td><td class="confluenceTd"><p><span style="color: rgb(68,68,68);">Any value greater than 0 suggests that some level of blocking is occurring. It is best practice to compare the current value against a baseline to determine what is normal for your SQL Server. An increasing lock wait time indicates potential resource contention.</span></p></td></tr><tr><td colspan="1" class="confluenceTd">Check also</td><td colspan="1" class="confluenceTd"><p><strong>Buffer cache hit ratio</strong><span style="color: rgb(68,68,68);">. If this value is above 90%, look at the&nbsp;</span><strong>Avg. disk queue length</strong><span style="color: rgb(68,68,68);">. Excessive disk queueing may be caused by badly configured or inadequately sized disk subsystems. You may want to review indexing and investigate the numbers of concurrent connections. If the&nbsp;</span><strong>Buffer cache hit ratio</strong><span style="color: rgb(68,68,68);">&nbsp;is below 90%, additional RAM may be required.</span></p></td></tr></tbody></table></div><h3 id="Listofmetrics-Avg.lockwaittime">Avg. lock wait time</h3><p><span style="color: rgb(68,68,68);">T<span style="color: rgb(68,68,68);">he average wait time (in milliseconds) for each lock that could not be satisfied immediately and had to wait for resources.</span></span></p><div class="table-wrap"><table class="confluenceTable"><tbody><tr><td class="confluenceTd">Equivalent PerfMon counter</td><td class="confluenceTd"><span style="color: rgb(68,68,68);">SQLServer:Locks - Average Wait Time (ms)</span></td></tr><tr><td class="confluenceTd">Explanation</td><td class="confluenceTd"><p><span style="color: rgb(68,68,68);">Locks are held on SQL Server resources to stop them from being used simultaneously by another transaction. For example, if a transaction holds an exclusive lock on a row, no other transaction can make changes to that row until the lock is removed. Fewer locks allow more concurrent transactions to take place and this may improve performance.</span></p></td></tr><tr><td class="confluenceTd">Guideline values</td><td class="confluenceTd"><p><span style="color: rgb(68,68,68);">Average wait times of 500 ms or more may indicate excessive blocking and should be investigated. In general,&nbsp;</span><strong>Avg. lock wait time</strong><span style="color: rgb(68,68,68);">&nbsp;correlates with&nbsp;</span><strong>Lock waits/sec</strong><span style="color: rgb(68,68,68);">, and if you see both of them increasing, you need to investigate what is causing the blocking issues.</span></p></td></tr><tr><td colspan="1" class="confluenceTd">Check also</td><td colspan="1" class="confluenceTd"><p><strong>Lock waits/sec</strong><span style="color: rgb(68,68,68);">&nbsp;to identify peaks over time, and&nbsp;</span><strong>Lock timeouts/sec</strong><span style="color: rgb(68,68,68);">&nbsp;to see how many locks reached the threshold set using the SET LOCK_TIMEOUT command.</span></p></td></tr></tbody></table></div><h2 id="Listofmetrics-Databasemetrics">Database metrics</h2><h3 id="Listofmetrics-Transactions/sec">Transactions/sec</h3><p><span style="color: rgb(68,68,68);">Number of transactions started for the database per second. Each data point shows the average number of transactions per second since the previous data point.</span></p><div class="table-wrap"><table class="confluenceTable"><tbody><tr><td class="confluenceTd">Equivalent PerfMon counter</td><td class="confluenceTd"><span style="color: rgb(68,68,68);">SQLServer:Databases - Transactions/sec</span></td></tr><tr><td class="confluenceTd">Explanation</td><td class="confluenceTd"><p><span style="color: rgb(68,68,68);">A transaction is one or more database operations combined into a single operation; either user-defined transactions surrounded by BEGIN TRAN and COMMIT TRAN or individual data modification statements such as INSERT or UPDATE. Transaction rate is affected by general system performance and resources such as I/O, number of users, cache size, and complexity of requests.This counter records only explicit transactions or transactions that change data.</span></p><p><span style="color: rgb(68,68,68);"><span style="color: rgb(68,68,68);">Note: Transactions per second only measures activity inside a transaction, not all activity, The&nbsp;</span><strong>Batch requests/sec</strong><span style="color: rgb(68,68,68);">&nbsp;metric is a more complete picture of all SQL Server activity.</span></span></p></td></tr><tr><td class="confluenceTd">Guideline values</td><td class="confluenceTd"><p><span style="color: rgb(68,68,68);">A high number of transactions per second is not necessarily an indication of a problem, only that there is a lot of activity on your SQL Server. You should establish a baseline value and track when transactions are unusually high or low.</span></p></td></tr></tbody></table></div><h3 id="Listofmetrics-Activetransactions">Active transactions</h3><p><span style="color: rgb(68,68,68);">Number of active transactions for the database. Each data point shows the number of active transactions at the point the data was collected.</span></p><div class="table-wrap"><table class="confluenceTable"><tbody><tr><td class="confluenceTd">Equivalent PerfMon counter</td><td class="confluenceTd"><span style="color: rgb(68,68,68);">SQLServer:Databases - Active Transactions</span></td></tr><tr><td class="confluenceTd">Explanation</td><td class="confluenceTd"><p><span style="color: rgb(68,68,68);">Active transactions are UPDATE transactions on the database that that have not yet been committed or rolled back.</span></p><p><span style="color: rgb(68,68,68);"><span style="color: rgb(68,68,68);">Note: This metric measures activity inside a transaction, not all activity. The&nbsp;</span><strong>Batch requests/sec</strong><span style="color: rgb(68,68,68);">&nbsp;metric is a more complete picture of all SQL Server activity.</span></span></p></td></tr><tr><td class="confluenceTd">Guideline values</td><td class="confluenceTd"><p><span style="color: rgb(68,68,68);">Generally, the number of active transactions should be considerably lower than the number of&nbsp;</span><strong>Transactions/sec</strong><span style="color: rgb(68,68,68);">(as active transactions show only those transactions that have not yet completed). If the number of transactions currently active is higher than the&nbsp;</span><strong>Transactions/sec</strong><span style="color: rgb(68,68,68);">&nbsp;metric, then this may indicate you have long-running transactions. Long running transactions can increase lock times and cause blocking.</span></p></td></tr></tbody></table></div><h3 id="Listofmetrics-Totalsize">Total size</h3><p><span style="color: rgb(68,68,68);">The total size (in GB) of all data files (.mdf and .ndf) and log files (.ldf) for this database.</span></p><div class="table-wrap"><table class="confluenceTable"><tbody><tr><td class="confluenceTd">Equivalent PerfMon counter</td><td class="confluenceTd"><span style="color: rgb(68,68,68);"><span style="color: rgb(68,68,68);">SQLServer:Databases - Data File(s) Size (KB) + SQLServer:Databases - Log File(s) Size (KB)</span></span></td></tr><tr><td class="confluenceTd">Explanation</td><td class="confluenceTd"><p><span style="color: rgb(68,68,68);">This value is the sum of the total data files and total log files sizes. It is useful for determining the amount of space required by the database and identifying trends.</span></p></td></tr><tr><td class="confluenceTd">Guideline values</td><td class="confluenceTd"><p><span style="color: rgb(68,68,68);">For best practice, MDF, NDF, and LDF files should be proactively managed in order to prevent autogrowth from kicking in and growing your database files.</span></p><p><span style="color: rgb(68,68,68);"><span style="color: rgb(68,68,68);">Note: If the values for this metric drop to zero intermittently, the most likely cause is a problem affecting sys.master_files from which SQL Monitor collects the data.</span></span></p></td></tr><tr><td colspan="1" class="confluenceTd">Check also</td><td colspan="1" class="confluenceTd"><strong>Log size</strong><span style="color: rgb(68,68,68);">&nbsp;for details of total .ldf files, and&nbsp;</span><strong>Data size</strong><span style="color: rgb(68,68,68);">&nbsp;for details of total .mdf and .ndf files.</span></td></tr></tbody></table></div><h3 id="Listofmetrics-Datasize">Data size</h3><p><span style="color: rgb(68,68,68);">Total size of all data files (.mdf and .ndf files) for the specified database.</span></p><div class="table-wrap"><table class="confluenceTable"><tbody><tr><td class="confluenceTd">Equivalent PerfMon counter</td><td class="confluenceTd"><span style="color: rgb(68,68,68);">SQLServer:Databases - Data File(s) Size (KB)</span></td></tr><tr><td class="confluenceTd">Explanation</td><td class="confluenceTd"><p><span style="color: rgb(68,68,68);">This value is the total size of the database, excluding the transaction log. Information about individual primary data files (.mdf) and secondary data files (.ndf) such as their current size, location, and autogrowth settings, is shown under the&nbsp;</span><strong>Files</strong><span style="color: rgb(68,68,68);">section of the Database overview page in SQL Server Management Studio.</span></p></td></tr><tr><td class="confluenceTd">Guideline values</td><td class="confluenceTd"><p><span style="color: rgb(68,68,68);">Look out for unusual large increases in the size of your data files. Ideally your database should be sized in a way that minimizes autogrowth, as each size increase is expensive in terms of I/O and will also physically fragment your data and log files.</span></p><p><span style="color: rgb(68,68,68);"><span style="color: rgb(68,68,68);">Growing a file on demand is an expensive process and will impact performance. Autogrowth should only be used as a safety valve to allow a database to grow should you accidently run out of space. It should not be used to manage your MDF file growth.</span></span></p><p><span style="color: rgb(68,68,68);"><span style="color: rgb(68,68,68);"><span style="color: rgb(68,68,68);">In general, data files should be pre-sized when they are first created to meet future expected growth, help avoid file fragmentation and ensure better database performance.</span></span></span></p><p><span style="color: rgb(68,68,68);"><span style="color: rgb(68,68,68);"><span style="color: rgb(68,68,68);"><span style="color: rgb(68,68,68);">Note: If the values for this metric drop to zero intermittently, the most likely cause is a problem affecting sys.master_files from which SQL Monitor collects the data.</span></span></span></span></p></td></tr><tr><td colspan="1" class="confluenceTd">Check also</td><td colspan="1" class="confluenceTd"><ul style="margin-left: 1.0em;"><li>Full Recovery Mode is used for all production databases.</li><li>When using Full Recovery Mode, be sure you take regular full and transaction log backups.</li><li>The files are set to be the amount of space you need for normal activity. Monitor the data files and manually add space as data grows. You should have 6-12 months of space for data growth in your data files.</li><li>If you don't have space for the database to grow at its current rate, move the database to a larger disk drive or upgrade the disk itself.</li></ul><p><strong>Caution:</strong><span style="color: rgb(68,68,68);">&nbsp;Shrinking files to reduce space causes fragmentation and is not recommended.</span></p></td></tr></tbody></table></div><h3 id="Listofmetrics-Logsize">Log size</h3><p><span style="color: rgb(68,68,68);">Total size of all log files (.ldf) for this database.</span></p><div class="table-wrap"><table class="confluenceTable"><tbody><tr><td class="confluenceTd">Equivalent PerfMon counter</td><td class="confluenceTd"><span style="color: rgb(68,68,68);">S<span style="color: rgb(68,68,68);">QLServer:Databases - Log File(s) Size (KB)</span></span></td></tr><tr><td class="confluenceTd">Explanation</td><td class="confluenceTd"><p><span style="color: rgb(68,68,68);">Each transaction performed in the database is recorded in the transaction log. This allows recovery in the event of data loss since the last backup. Information about the log file (.ldf) such as its location, autogrowth setting and current size, is shown under the&nbsp;</span><strong>Files</strong><span style="color: rgb(68,68,68);">&nbsp;section of the Database overview page in SQL Server Management Studio.</span></p></td></tr><tr><td class="confluenceTd">Guideline values</td><td class="confluenceTd"><p><span style="color: rgb(68,68,68);">Transaction logs are serial records of database modifications. They're used during recovery operations to commit completed transactions and to roll back uncompleted transactions. The size of the log file is determined by the Recovery Model set for the database. By default when creating a new database it will use the Full recovery mode (inherited from the Model database), where transactions in the log file are only ever removed when a transaction log backup is performed. When you back up a transaction log, the backup stores the changes that have occurred since the last transaction log backup and then truncates the log, which clears out transactions that have been committed or aborted. If the transaction log is not backed up regularly, it will grow indefinitely in size and could fill your entire disk.</span></p><p><span style="color: rgb(68,68,68);"><span style="color: rgb(68,68,68);">Note: If the values for this metric drop to zero intermittently, the most likely cause is a problem affecting sys.master_files from which SQL Monitor collects the data.</span></span></p></td></tr><tr><td colspan="1" class="confluenceTd">Check also</td><td colspan="1" class="confluenceTd"><ul style="margin-left: 1.0em;"><li>The transaction log file should be pre-allocated to the size you think it needs to be when your system is in production. This size will depend on the number of transactions you expect, and how often you backup the transaction log.</li><li>Set correct autogrowth properties: 10% autogrowth for data and log files (the default setting) may be sufficient for low utilization databases, but 500 MB autogrowth rate may be more suitable for a busy database, allowing for growth over time without the heavy I/O impact caused by regular autogrowth operations. Even in Simple recovery model, if you are writing to the transaction log fast enough, the checkpoint process cannot keep up, and the log file will trigger autogrowth.</li><li>If you are performing a one-off bulk insert operation, you may want to switch the recovery model to bulk logged for the duration of the insert.</li><li>If you do not need point-in-time recovery for this database, then it may be appropriate to switch to Simple recovery model.</li><li>If a database is configured with the Full or Bulk Logged recovery model, you should back up the transaction log regularly so it can be truncated to free up inactive log space. Truncating a log file removes inactive virtual log files, but does not reduce the file size.</li></ul></td></tr></tbody></table></div><h3 id="Listofmetrics-Logspaceused">Log space used</h3><p><span style="color: rgb(68,68,68);">Percentage of total transaction log file size currently containing log records.</span></p><div class="table-wrap"><table class="confluenceTable"><tbody><tr><td class="confluenceTd">Equivalent PerfMon counter</td><td class="confluenceTd"><span style="color: rgb(68,68,68);">SQLServer:Databases - Log File(s) Used Size (KB)</span></td></tr><tr><td class="confluenceTd">Explanation</td><td class="confluenceTd"><p><span style="color: rgb(68,68,68);">The transaction log file stores the details of all the modifications that you perform on your SQL Server database. The amount of space it takes up depends on the recovery model used, database activity, how often transaction logs are backed up, among other factors.</span></p></td></tr><tr><td class="confluenceTd">Guideline values</td><td class="confluenceTd"><p><span style="color: rgb(68,68,68);">It is normal to see the log space figure to vary considerably in size over time as transactions are recorded, and removed when log backups are performed.</span></p></td></tr></tbody></table></div><h3 id="Listofmetrics-Logbytesflushed/sec">Log bytes flushed/sec</h3><p><span style="color: rgb(68,68,68);">Shown on the Availability group overview as&nbsp;</span><strong>Log growth</strong><span style="color: rgb(68,68,68);">.</span></p><p><span style="color: rgb(68,68,68);"><span style="color: rgb(68,68,68);">Average size of the log flush per second. Each data point shows the average log bytes flushed per second for this database since the previous data point.</span></span></p><div class="table-wrap"><table class="confluenceTable"><tbody><tr><td class="confluenceTd">Equivalent PerfMon counter</td><td class="confluenceTd"><span style="color: rgb(68,68,68);">S<span style="color: rgb(68,68,68);">QLServer:Databases - Log Bytes Flushed/sec</span></span></td></tr><tr><td class="confluenceTd">Explanation</td><td class="confluenceTd"><p><span style="color: rgb(68,68,68);">This metric helps to assess utilization and identify trends of the transaction log. A log flush occurs when data is written from the log cache to the physical transaction log file on disk, every time a transaction is committed.</span></p><p><span style="color: rgb(68,68,68);"><span style="color: rgb(68,68,68);">Within availability groups, both the primary and the secondary replicas have a&nbsp;</span><strong>log bytes flushed</strong><span style="color: rgb(68,68,68);">&nbsp;rate. On the primary replica, this shows how quickly log records are being added to the&nbsp;</span><strong>log send queue</strong><span style="color: rgb(68,68,68);">. On the secondary, it shows how quickly log bytes are being added to the&nbsp;</span><strong>redo queue</strong><span style="color: rgb(68,68,68);">.</span></span></p><p><span style="color: rgb(68,68,68);"><span style="color: rgb(68,68,68);"><span style="color: rgb(68,68,68);">The Availability group overview page only shows the rate of log bytes flushed on the primary replica.</span></span></span></p></td></tr><tr><td class="confluenceTd">Guideline values</td><td class="confluenceTd"><p><span style="color: rgb(68,68,68);">The size of a log flush varies depending on the nature of the transaction. For example, a single INSERT into 1,000,000 rows will result in a single log flush, but a high number of bytes.</span></p><p><span style="color: rgb(68,68,68);"><span style="color: rgb(68,68,68);">Within availability groups, if the rate of&nbsp;</span><strong>log bytes flushed</strong><span style="color: rgb(68,68,68);">&nbsp;on the primary replica is higher than the rate at which log bytes are sent, the size of the&nbsp;</span><strong>log send queue&nbsp;</strong><span style="color: rgb(68,68,68);">will increase. To estimate the potential data loss on failover (in asynchronous-commit mode), divide the&nbsp;</span><strong>log send queue</strong><span style="color: rgb(68,68,68);">&nbsp;by the&nbsp;</span><strong>log bytes flushed</strong><span style="color: rgb(68,68,68);">.</span></span></p><p><span style="color: rgb(68,68,68);"><span style="color: rgb(68,68,68);"><span style="color: rgb(68,68,68);">If the rate of&nbsp;</span><strong>log bytes flushed</strong><span style="color: rgb(68,68,68);">&nbsp;on the secondary replica is higher than the&nbsp;</span><strong>redo rate</strong><span style="color: rgb(68,68,68);">, the size of the&nbsp;</span><strong>redo queue</strong><span style="color: rgb(68,68,68);">&nbsp;will increase.</span></span></span></p></td></tr><tr><td colspan="1" class="confluenceTd">Check also</td><td colspan="1" class="confluenceTd"><ul style="margin-left: 1.0em;"><li><strong>Log flushes/sec</strong>: The number of log pages flushed to the transaction log per second.</li><li><strong>Log send queue</strong>: The amount of log records in the primary database log file waiting to be sent to the secondary replica.</li><li><strong>Redo queue</strong>: The amount of log records that needs to be redone (written to the secondary database) for the synchronous-commit primary and secondary replicas to be synchronized.</li></ul></td></tr></tbody></table></div><h3 id="Listofmetrics-Logflushes/sec">Log flushes/sec</h3><p><span style="color: rgb(68,68,68);">Number of log flushes per second for this database, averaged since last collection time.</span></p><div class="table-wrap"><table class="confluenceTable"><tbody><tr><td class="confluenceTd">Equivalent PerfMon counter</td><td class="confluenceTd"><span style="color: rgb(68,68,68);">SQLServer:Databases - Log Flushes/sec</span></td></tr><tr><td class="confluenceTd">Explanation</td><td class="confluenceTd"><p><span style="color: rgb(68,68,68);">A log flush occurs when a transaction is committed and data is written from the log cache to the physical transaction log file. The log cache is a temporary location in memory where SQL Server stores data to be written to the log file, and is used to roll back a transaction before it is committed if required. Once a transaction is completed (and can no longer be rolled back), the log cache is immediately flushed to the physical log file on disk.</span></p></td></tr><tr><td class="confluenceTd">Guideline values</td><td class="confluenceTd"><p><span style="color: rgb(68,68,68);">Log flushes per second should generally correlate with the number of transactions per second. If log flushes per second seems to be significantly higher than the expected number of transactions, check your use of explicit transactions in queries.</span></p><p><span style="color: rgb(68,68,68);"><span style="color: rgb(68,68,68);">Explicitly defining the start and end of transactions (rather than implicit transactions, where SQL Server needs to flush the log for each data statement) should reduce the number of log flushes, and reduce impact on I/O.</span></span></p></td></tr><tr><td colspan="1" class="confluenceTd">Check also</td><td colspan="1" class="confluenceTd"><p><strong>Log bytes flushed/sec</strong></p></td></tr></tbody></table></div><h3 id="Listofmetrics-Logflushwaits/sec">Log flush waits/sec</h3><p><span style="color: rgb(68,68,68);">Number of transaction commits per second waiting to be flushed from the log cache to the physical transaction log file on disk.</span></p><div class="table-wrap"><table class="confluenceTable"><tbody><tr><td class="confluenceTd">Equivalent PerfMon counter</td><td class="confluenceTd"><span style="color: rgb(68,68,68);"><span><span style="color: rgb(68,68,68);">SQLServer:Databases - Log Flush Waits/sec</span>g Bytes Flushed/sec</span></span></td></tr><tr><td class="confluenceTd">Explanation</td><td class="confluenceTd"><p><span style="color: rgb(68,68,68);">A high number of log flush waits indicates that it is taking longer than normal to flush the transaction log cache to the file on disk, which will slow SQL Server's performance.</span></p></td></tr><tr><td class="confluenceTd">Guideline values</td><td class="confluenceTd"><p><span style="color: rgb(68,68,68);">Log flush waits should be as close to 0 as possible.</span></p></td></tr><tr><td colspan="1" class="confluenceTd">Check also</td><td colspan="1" class="confluenceTd"><p><strong>Disk avg. write time.</strong><span style="color: rgb(68,68,68);">&nbsp;If this is greater than 5 ms, then an I/O bottleneck is likely to be occurring.</span></p></td></tr><tr><td colspan="1" class="confluenceTd">Possible solutions</td><td colspan="1" class="confluenceTd"><span style="color: rgb(68,68,68);">Moving the location of your transaction log (LDF file) to a separate physical drive from your data files (MDF files) will increase performance, as writing to the log and data files will not be competing for access to the same disk. Also consider using faster disk drives, using RAID 10 for transaction log file storage, adding additional spindles to your existing RAID array, short-stroking, or adding additional disk controllers.</span></td></tr></tbody></table></div><h2 id="Listofmetrics-Availabilitygroupmetrics">Availability group metrics</h2><h3 id="Listofmetrics-Logbytesreceived/sec"><span style="color: rgb(0,0,0);">Log bytes received/sec</span></h3><p>Shown on the&nbsp;<strong>Availability group overview</strong>&nbsp;as&nbsp;<strong>Received rate</strong>.</p><p><span style="color: rgb(68,68,68);">The rate at which the the secondary replica receives log records from the primary replica.</span></p><div class="table-wrap"><table class="confluenceTable"><tbody><tr><td class="confluenceTd">Equivalent PerfMon counter</td><td class="confluenceTd"><span style="color: rgb(68,68,68);">SQLServer:Database Replica - Log Bytes Received/sec</span></td></tr><tr><td class="confluenceTd">Explanation</td><td class="confluenceTd"><span style="color: rgb(68,68,68);">This value measures how quickly log records are received by the secondary replica.</span></td></tr><tr><td class="confluenceTd">Guideline values</td><td class="confluenceTd"><p><span style="color: rgb(68,68,68);">To estimate how long a secondary replica will take to catch up with the primary replica, divide the&nbsp;</span><strong>log send queue </strong><span style="color: rgb(68,68,68);">by the rate of&nbsp;</span><strong>log bytes received</strong><span style="color: rgb(68,68,68);">.</span></p></td></tr><tr><td colspan="1" class="confluenceTd">Check also</td><td colspan="1" class="confluenceTd"><ul style="margin-left: 1.0em;"><li><strong>Log send queue</strong>: Amount of log records in the primary database log file waiting to be sent to the secondary replica.</li><li><strong>Log bytes flushed/sec</strong>&nbsp;(on the secondary): Average size of the log flush per second.</li></ul></td></tr></tbody></table></div><h3 id="Listofmetrics-Logsendqueue"><span style="color: rgb(0,0,0);">Log send queue</span></h3><p><span style="color: rgb(68,68,68);">Shown on the&nbsp;</span><strong>Availability group overview</strong><span style="color: rgb(68,68,68);">&nbsp;as&nbsp;</span><strong>Send queue</strong><span style="color: rgb(68,68,68);">.</span></p><p><span style="color: rgb(68,68,68);">Amount of log records in the primary database log file waiting to be sent to the secondary replica.</span></p><div class="table-wrap"><table class="confluenceTable"><tbody><tr><td class="confluenceTd">Equivalent PerfMon counter</td><td class="confluenceTd"><span style="color: rgb(68,68,68);">SQLServer:Database Replica - Log Send Queue</span></td></tr><tr><td class="confluenceTd">Explanation</td><td class="confluenceTd"><span style="color: rgb(68,68,68);">This value is the amount of log data that has been flushed to disk on the primary replica but hasn't yet been sent to the secondary replica.</span></td></tr><tr><td class="confluenceTd">Guideline values</td><td class="confluenceTd"><p><span style="color: rgb(68,68,68);">The rate of&nbsp;</span><strong>log bytes flushed</strong><span style="color: rgb(68,68,68);">&nbsp;(on the primary replica) adds to the&nbsp;</span><strong>log send queue</strong><span style="color: rgb(68,68,68);">. I</span><span style="color: rgb(68,68,68);">f the rate of&nbsp;</span><strong>log bytes flushed</strong><span style="color: rgb(68,68,68);">&nbsp;on the primary is higher than the rate at which log records are sent</span><span style="color: rgb(68,68,68);">, the&nbsp;</span><strong>log send queue</strong><span style="color: rgb(68,68,68);">&nbsp;will increase. </span></p><p><span style="color: rgb(68,68,68);">To estimate the potential data loss on failover (in asynchronous-commit mode), divide the&nbsp;</span><strong>log send queue</strong><span style="color: rgb(68,68,68);">&nbsp;by the&nbsp;</span><strong>log bytes flushed</strong><span style="color: rgb(68,68,68);">.</span></p><p><span style="color: rgb(68,68,68);"><span style="color: rgb(68,68,68);">From the&nbsp;</span><strong>log send queue</strong><span style="color: rgb(68,68,68);">, the log records are sent to the secondary replica. To estimate how long it will take the secondary replica to catch up with the primary replica, divide the&nbsp;</span><strong>log send queue</strong><span style="color: rgb(68,68,68);">&nbsp;by the&nbsp;</span><strong>log bytes received/sec</strong><span style="color: rgb(68,68,68);">.</span></span></p><p><span style="color: rgb(68,68,68);"><span style="color: rgb(68,68,68);"><span style="color: rgb(68,68,68);">If you use the secondary replica for reporting and want to know how much data from the primary replica is not yet represented in the secondary replica, add together the&nbsp;</span><strong>log send queue</strong><span style="color: rgb(68,68,68);">&nbsp;and the&nbsp;</span><strong>redo queue</strong><span style="color: rgb(68,68,68);">.</span></span></span></p></td></tr><tr><td colspan="1" class="confluenceTd">Check also</td><td colspan="1" class="confluenceTd"><p><strong>Log bytes flushed/sec</strong>: Average size of the log flush per second.</p></td></tr></tbody></table></div><h3 id="Listofmetrics-Redoqueue"><span>Redo queue</span></h3><p><span style="color: rgb(68,68,68);">The amount of log records that needs to be redone (written to the secondary database) for the synchronous-commit primary and secondary replicas to be synchronized.</span></p><div class="table-wrap"><table class="confluenceTable"><tbody><tr><td class="confluenceTd">Equivalent PerfMon counter</td><td class="confluenceTd"><span style="color: rgb(68,68,68);">SQLServer:Database Replica - Recovery Queue</span></td></tr><tr><td class="confluenceTd">Explanation</td><td class="confluenceTd"><span style="color: rgb(68,68,68);">After the log data has been hardened into the secondary replica's log file, it joins the&nbsp;</span><strong>redo queue</strong><span style="color: rgb(68,68,68);">.</span></td></tr><tr><td class="confluenceTd">Guideline values</td><td class="confluenceTd"><p><span style="color: rgb(68,68,68);">The rate of&nbsp;</span><strong>log bytes received</strong><span style="color: rgb(68,68,68);">&nbsp;adds to the size of the redo queue, while the&nbsp;</span><strong>redo rate</strong><span style="color: rgb(68,68,68);">&nbsp;takes away from it. If the rate of&nbsp;</span><strong>log bytes received</strong><span style="color: rgb(68,68,68);">&nbsp;is higher than the&nbsp;</span><strong>redo rate</strong><span style="color: rgb(68,68,68);">, the size of the&nbsp;</span><strong>redo queue</strong><span style="color: rgb(68,68,68);">&nbsp;will increase.</span></p><p><span style="color: rgb(68,68,68);"><span style="color: rgb(68,68,68);">In event of a failover, the&nbsp;</span><strong>redo queue</strong><span style="color: rgb(68,68,68);">&nbsp;needs to be cleared before the secondary replica can transition to the role of primary replica. To estimate the time, in seconds, that it will take the secondary replica to redo the log (and therefore how long failover will take), divide the&nbsp;</span><strong>redo queue</strong><span style="color: rgb(68,68,68);">&nbsp;by the&nbsp;</span><strong>redo rate</strong><span style="color: rgb(68,68,68);">.</span></span></p><p><span style="color: rgb(68,68,68);"><span style="color: rgb(68,68,68);"><span style="color: rgb(68,68,68);">If you use the secondary replica for reporting and want to know how much data from the primary replica is not yet represented in the secondary replica, add together the&nbsp;</span><strong>log send queue</strong><span style="color: rgb(68,68,68);">&nbsp;and the&nbsp;</span><strong>redo queue</strong><span style="color: rgb(68,68,68);">.</span></span></span></p></td></tr><tr><td colspan="1" class="confluenceTd">Check also</td><td colspan="1" class="confluenceTd"><ul style="margin-left: 1.0em;"><li><strong>Log send queue</strong>: Amount of log records in the primary database log file waiting to be sent to the secondary replica.</li><li><strong style="line-height: 1.42857;">Log bytes received/sec</strong><span style="line-height: 1.42857;">: The rate at which the secondary replica receives log records from the primary replica.</span></li><li><strong>Redo queue</strong>: The rate at which log records are redone in the secondary database to complete synchronization.</li></ul></td></tr></tbody></table></div><h3 id="Listofmetrics-Redorate">Redo rate</h3><p><span style="color: rgb(68,68,68);">The rate at which log records are redone (written to the secondary database).</span></p><div class="table-wrap"><table class="confluenceTable"><tbody><tr><td class="confluenceTd">Equivalent PerfMon counter</td><td class="confluenceTd"><span style="color: rgb(68,68,68);">SQLServer:Database Replica - Redone Bytes/sec</span></td></tr><tr><td class="confluenceTd">Explanation</td><td class="confluenceTd"><span style="color: rgb(68,68,68);">Log records from the&nbsp;</span><strong>redo queue</strong><span style="color: rgb(68,68,68);">&nbsp;are written to the secondary database, completing the synchronization process. If the&nbsp;</span><strong>redo rate</strong><span style="color: rgb(68,68,68);">&nbsp;is lower than the rate of&nbsp;</span><strong>log bytes flushed</strong><span style="color: rgb(68,68,68);">&nbsp;on the secondary replica, the size of the&nbsp;</span><strong>redo queue</strong><span style="color: rgb(68,68,68);">&nbsp;will increase.</span></td></tr><tr><td class="confluenceTd">Guideline values</td><td class="confluenceTd"><span style="color: rgb(68,68,68);">To estimate the time, in seconds, that it will take the secondary replica to redo the log, divide the&nbsp;</span><strong>redo queue</strong><span style="color: rgb(68,68,68);">&nbsp;by the&nbsp;</span><strong>redo rate</strong><span style="color: rgb(68,68,68);">.</span></td></tr><tr><td colspan="1" class="confluenceTd">Check also</td><td colspan="1" class="confluenceTd"><ul><li><strong>Log bytes flushed/sec</strong><span style="color: rgb(68,68,68);">&nbsp;(on secondary replica): Average size of the log flush per second.</span></li><li><strong>Redo queue</strong>: The amount of log records that needs to be redone (written to the secondary database) for the synchronous-commit primary and secondary replicas to be synchronized.<span style="color: rgb(68,68,68);"><br></span></li></ul></td></tr></tbody></table></div><h3 id="Listofmetrics-Transactiondelayms/sec">Transaction delay ms/sec</h3><p><span style="color: rgb(68,68,68);">This value measures the extent to which transactions are slowed down by synchronous replication.</span></p><div class="table-wrap"><table class="confluenceTable"><tbody><tr><td class="confluenceTd">Equivalent PerfMon counter</td><td class="confluenceTd"><span style="color: rgb(68,68,68);">SQLServer:Database Replica - <span style="color: rgb(68,68,68);">Transaction Delay</span></span></td></tr><tr><td class="confluenceTd">Explanation</td><td class="confluenceTd"><span style="color: rgb(68,68,68);">In synchronous-commit mode, the primary replica doesn't commit any transactions until it receives acknowledgement that all synchronous secondary replicas have finished hardening the log, resulting in&nbsp;</span><strong>transaction delay</strong><span style="color: rgb(68,68,68);">. This is the total delay across all transactions caused by the primary replica waiting for commit acknowledgement from the secondary replicas. As such, it's useful for working out whether activity on the secondary replicas is slowing down the primary replica.</span></td></tr><tr><td class="confluenceTd">Guideline values</td><td class="confluenceTd"><span style="color: rgb(68,68,68);">The&nbsp;</span><strong>flow control time</strong><span style="color: rgb(68,68,68);">&nbsp;contributes to the&nbsp;</span><strong>transaction delay</strong><span style="color: rgb(68,68,68);">&nbsp;on synchronous-commit replicas, because it affects the rate at which log records are sent. The rate of&nbsp;</span><strong>log bytes flushed</strong><span style="color: rgb(68,68,68);">&nbsp;on the secondary replica also affects the&nbsp;</span><strong>transaction delay</strong><span style="color: rgb(68,68,68);">.</span></td></tr><tr><td colspan="1" class="confluenceTd">Check also</td><td colspan="1" class="confluenceTd"><ul><li><strong>Log bytes flushed/sec</strong><span style="color: rgb(68,68,68);">&nbsp;(on secondary replica): Average size of the log flush per second.</span></li><li><strong style="line-height: 1.42857;">Flow control time/sec</strong><span style="line-height: 1.42857;">: The total time that log records wait per second due to flow control.</span></li></ul></td></tr></tbody></table></div><h3 id="Listofmetrics-Flowcontroltimems/sec">Flow control time ms/sec</h3><p><span style="color: rgb(68,68,68);">The total time that log records waited per second due to flow control.</span></p><div class="table-wrap"><table class="confluenceTable"><tbody><tr><td class="confluenceTd">Equivalent PerfMon counter</td><td class="confluenceTd"><span style="color: rgb(68,68,68);">SQLServer:Availability Replica - Flow Control Time (ms/sec)</span></td></tr><tr><td class="confluenceTd">Explanation</td><td class="confluenceTd"><span style="color: rgb(68,68,68);">Flow control throttles the flow of network traffic caused by replication, by limiting the speed at which the primary replica sends log records to the secondary replica. This helps to even out the usage of network and memory resources. This value shows the total time, in milliseconds per second, that the log records had to wait before being sent to the secondary replica, because of flow control.</span></td></tr><tr><td class="confluenceTd">Guideline values</td><td class="confluenceTd"><p><span style="color: rgb(68,68,68);">Flow control can restrict the rate at which log records are sent from the primary replica. This will affect the&nbsp;</span><strong>log send queue</strong><span style="color: rgb(68,68,68);">: if the rate at which log records are sent is lower than the rate of&nbsp;</span><strong>log bytes flushed</strong><span style="color: rgb(68,68,68);">&nbsp;(on the primary replica), the&nbsp;</span><strong>log send queue</strong><span style="color: rgb(68,68,68);">&nbsp;will increase.</span></p><p><span style="color: rgb(68,68,68);"><span style="color: rgb(68,68,68);">The&nbsp;</span><strong>flow control</strong><span style="color: rgb(68,68,68);">&nbsp;time also contributes to the&nbsp;</span><strong>transaction delay</strong><span style="color: rgb(68,68,68);">&nbsp;on synchronous replicas, because it affects the rate at which log data is transferred between the primary and the secondary replicas.</span></span></p></td></tr><tr><td colspan="1" class="confluenceTd">Check also</td><td colspan="1" class="confluenceTd"><ul><li><strong>Log bytes flushed/sec</strong><span style="color: rgb(68,68,68);">&nbsp;(on secondary replica): Average size of the log flush per second.<br></span></li><li><strong>Log send queue</strong>: Amount of log records in the primary database log file waiting to be sent to the secondary replica.</li><li><span style="color: rgb(68,68,68);"><strong>Transaction delay</strong><span style="color: rgb(68,68,68);">: The extent to which transactions are slowed down by synchronous replication.</span></span></li></ul></td></tr></tbody></table></div>
        </div>
            <div class="grid__col grid__col--span-4-of-12">
            <div class="panel panel-default border spaced-bottom conf-macro output-block" data-hasbody="true" data-macro-name="sp-macrooverride-richtextbody-block">
        <div class="panel-body padded--tight">
        <div class="toc-macro client-side-toc-macro  conf-macro output-block" data-headerelements="H1,H2,H3,H4,H5,H6,H7" data-hasbody="false" data-macro-name="toc"> <ul><li><a href="https://documentation.red-gate.com/sm/analysis-graph/list-of-metrics#Listofmetrics-Machinemetrics">Machine metrics</a></li><ul><li><a href="https://documentation.red-gate.com/sm/analysis-graph/list-of-metrics#Listofmetrics-Machine:processortime">Machine: processor time</a></li><li><a href="https://documentation.red-gate.com/sm/analysis-graph/list-of-metrics#Listofmetrics-Avg.CPUqueuelength">Avg. CPU queue length</a></li><li><a href="https://documentation.red-gate.com/sm/analysis-graph/list-of-metrics#Listofmetrics-Machine:memoryused">Machine: memory used</a></li><li><a href="https://documentation.red-gate.com/sm/analysis-graph/list-of-metrics#Listofmetrics-Memorypages/sec">Memory pages/sec</a></li><li><a href="https://documentation.red-gate.com/sm/analysis-graph/list-of-metrics#Listofmetrics-Networkutilization">Network utilization</a></li><li><a href="https://documentation.red-gate.com/sm/analysis-graph/list-of-metrics#Listofmetrics-Diskused">Disk used</a></li><li><a href="https://documentation.red-gate.com/sm/analysis-graph/list-of-metrics#Listofmetrics-Diskavg.readtime">Disk avg. read time</a></li><li><a href="https://documentation.red-gate.com/sm/analysis-graph/list-of-metrics#Listofmetrics-Diskavg.writetime">Disk avg. write time</a></li><li><a href="https://documentation.red-gate.com/sm/analysis-graph/list-of-metrics#Listofmetrics-Disktransfers/sec">Disk transfers/sec</a></li><li><a href="https://documentation.red-gate.com/sm/analysis-graph/list-of-metrics#Listofmetrics-Avg.diskqueuelength">Avg. disk queue length</a></li></ul><li><a href="https://documentation.red-gate.com/sm/analysis-graph/list-of-metrics#Listofmetrics-SQLServermetrics">SQL Server metrics</a></li><ul><li><a href="https://documentation.red-gate.com/sm/analysis-graph/list-of-metrics#Listofmetrics-Userconnections">User connections</a></li><li><a href="https://documentation.red-gate.com/sm/analysis-graph/list-of-metrics#Listofmetrics-SQLServer:processortime">SQL Server: processor time</a></li><li><a href="https://documentation.red-gate.com/sm/analysis-graph/list-of-metrics#Listofmetrics-SQLServer:totalmemory">SQL Server: total memory</a></li><li><a href="https://documentation.red-gate.com/sm/analysis-graph/list-of-metrics#Listofmetrics-SQLServer:targetmemory">SQL Server: target memory</a></li><li><a href="https://documentation.red-gate.com/sm/analysis-graph/list-of-metrics#Listofmetrics-SQLServer:freememory">SQL Server: free memory</a></li><li><a href="https://documentation.red-gate.com/sm/analysis-graph/list-of-metrics#Listofmetrics-Batchrequests/sec">Batch requests/sec</a></li><li><a href="https://documentation.red-gate.com/sm/analysis-graph/list-of-metrics#Listofmetrics-Compilations/sec">Compilations/sec</a></li><li><a href="https://documentation.red-gate.com/sm/analysis-graph/list-of-metrics#Listofmetrics-Compilations/batch">Compilations/batch</a></li><li><a href="https://documentation.red-gate.com/sm/analysis-graph/list-of-metrics#Listofmetrics-Recompilations/sec">Recompilations/sec</a></li><li><a href="https://documentation.red-gate.com/sm/analysis-graph/list-of-metrics#Listofmetrics-Buffercachehitratio">Buffer cache hit ratio</a></li><li><a href="https://documentation.red-gate.com/sm/analysis-graph/list-of-metrics#Listofmetrics-Bufferpagelifeexpectancy">Buffer page life expectancy</a></li><li><a href="https://documentation.red-gate.com/sm/analysis-graph/list-of-metrics#Listofmetrics-Fullscans/sec">Full scans/sec</a></li><li><a href="https://documentation.red-gate.com/sm/analysis-graph/list-of-metrics#Listofmetrics-Pagesplits/sec">Page splits/sec</a></li><li><a href="https://documentation.red-gate.com/sm/analysis-graph/list-of-metrics#Listofmetrics-Pagesplits/batchrequest">Page splits/batch request</a></li><li><a href="https://documentation.red-gate.com/sm/analysis-graph/list-of-metrics#Listofmetrics-Latchwaittime">Latch wait time</a></li><li><a href="https://documentation.red-gate.com/sm/analysis-graph/list-of-metrics#Listofmetrics-Locktimeouts/sec">Lock timeouts/sec</a></li><li><a href="https://documentation.red-gate.com/sm/analysis-graph/list-of-metrics#Listofmetrics-Lockwaits/sec">Lock waits/sec</a></li><li><a href="https://documentation.red-gate.com/sm/analysis-graph/list-of-metrics#Listofmetrics-Avg.lockwaittime">Avg. lock wait time</a></li></ul><li><a href="https://documentation.red-gate.com/sm/analysis-graph/list-of-metrics#Listofmetrics-Databasemetrics">Database metrics</a></li><ul><li><a href="https://documentation.red-gate.com/sm/analysis-graph/list-of-metrics#Listofmetrics-Transactions/sec">Transactions/sec</a></li><li><a href="https://documentation.red-gate.com/sm/analysis-graph/list-of-metrics#Listofmetrics-Activetransactions">Active transactions</a></li><li><a href="https://documentation.red-gate.com/sm/analysis-graph/list-of-metrics#Listofmetrics-Totalsize">Total size</a></li><li><a href="https://documentation.red-gate.com/sm/analysis-graph/list-of-metrics#Listofmetrics-Datasize">Data size</a></li><li><a href="https://documentation.red-gate.com/sm/analysis-graph/list-of-metrics#Listofmetrics-Logsize">Log size</a></li><li><a href="https://documentation.red-gate.com/sm/analysis-graph/list-of-metrics#Listofmetrics-Logspaceused">Log space used</a></li><li><a href="https://documentation.red-gate.com/sm/analysis-graph/list-of-metrics#Listofmetrics-Logbytesflushed/sec">Log bytes flushed/sec</a></li><li><a href="https://documentation.red-gate.com/sm/analysis-graph/list-of-metrics#Listofmetrics-Logflushes/sec">Log flushes/sec</a></li><li><a href="https://documentation.red-gate.com/sm/analysis-graph/list-of-metrics#Listofmetrics-Logflushwaits/sec">Log flush waits/sec</a></li></ul><li><a href="https://documentation.red-gate.com/sm/analysis-graph/list-of-metrics#Listofmetrics-Availabilitygroupmetrics">Availability group metrics</a></li><ul><li><a href="https://documentation.red-gate.com/sm/analysis-graph/list-of-metrics#Listofmetrics-Logbytesreceived/sec">Log bytes received/sec</a></li><li><a href="https://documentation.red-gate.com/sm/analysis-graph/list-of-metrics#Listofmetrics-Logsendqueue">Log send queue</a></li><li><a href="https://documentation.red-gate.com/sm/analysis-graph/list-of-metrics#Listofmetrics-Redoqueue">Redo queue</a></li><li><a href="https://documentation.red-gate.com/sm/analysis-graph/list-of-metrics#Listofmetrics-Redorate">Redo rate</a></li><li><a href="https://documentation.red-gate.com/sm/analysis-graph/list-of-metrics#Listofmetrics-Transactiondelayms/sec">Transaction delay ms/sec</a></li><li><a href="https://documentation.red-gate.com/sm/analysis-graph/list-of-metrics#Listofmetrics-Flowcontroltimems/sec">Flow control time ms/sec</a></li></ul></ul></div>
    </div>
</div>
        </div>
        </div>

                
<div class="clearfix spaced-top padded-top">
  <hr>
  <p class="delta">Didn't find what you were looking for?</p>

  <div class="float-left">
    <ul class="list--horizontal list--dividers">
      <li>Visit the <a href="https://forum.red-gate.com/">Redgate forum</a></li>
      <li><a href="http://redgatesupport.red-gate.com/home">Contact Support</a></li>
    </ul>
  </div>
  
</div>
            </div>
        </div>
      
    </div>
</section>
          
		<section class="band scheme--white hub__footer-links spaced-top">
            <div class="band__inner-container grid">
                <div class="grid__col grid__col--span-2-of-10">
                    <a href="https://www.red-gate.com/hub/product-learning/" class="rounded border display--block text--center padded spaced-right--tight">
                        <img src="./List of metrics - SQL Monitor 9 - Product Documentation_files/product-learning.svg" alt="" class="padded-bottom--tight">
                        <p class="beta">Product Articles</p>
                        <p>Tips and how-to guides for Redgate products</p>
                    </a>
                </div>

                <div class="grid__col grid__col--span-2-of-10">
                    <a href="https://www.red-gate.com/hub/university/" class="rounded border display--block text--center padded spaced-right--tight">
                        <img src="./List of metrics - SQL Monitor 9 - Product Documentation_files/university.svg" alt="" class="padded-bottom--tight">
                        <p class="beta">University</p>
                        <p>Easy to follow video courses</p>
                    </a>
                </div>

                <div class="grid__col grid__col--span-2-of-10">
                    <a href="https://forum.red-gate.com/" class="rounded border display--block text--center padded spaced-right--tight">
                        <img src="./List of metrics - SQL Monitor 9 - Product Documentation_files/product-forums.svg" alt="" class="padded-bottom--tight">
                        <p class="beta">Community Forums</p>
                        <p>Ask, discuss, and solve questions about Redgate's tools</p>
                    </a>
                </div>

                <div class="grid__col grid__col--span-2-of-10">
                    <a href="https://www.red-gate.com/hub/events/" class="rounded border display--block text--center padded spaced-right--tight">
                        <img src="./List of metrics - SQL Monitor 9 - Product Documentation_files/events-and-friends.svg" alt="" class="padded-bottom--tight">
                        <p class="beta">Events &amp; Friends</p>
                        <p>Meet us at an event, get sponsored, and join our Friends of Redgate</p>
                    </a>
                </div>

                <div class="grid__col grid__col--span-2-of-10">
                    <a href="https://www.red-gate.com/simple-talk/" class="rounded border display--block text--center padded spaced-right--tight">
                        <img src="./List of metrics - SQL Monitor 9 - Product Documentation_files/simple-talk.svg" alt="" class="padded-bottom--tight">
                        <p class="beta">Simple Talk</p>
                        <p>In-depth articles and opinion from Redgate's technical journal</p>
                    </a>
                </div>
            </div>
        </section>

		

		                                
		<script>
          var Confluence = Confluence || {};
          Confluence.Space = {
            "key": "SM9",
            "name": "SQL Monitor 9"
          };
          Confluence.Page = {
            "id": "67535219"
          };
          Confluence.BaseUrl = "https://documentation.red-gate.com";
		</script>

        <script src="./List of metrics - SQL Monitor 9 - Product Documentation_files/jquery.min.js.Без названия"></script>
        <script src="./List of metrics - SQL Monitor 9 - Product Documentation_files/jquery.scroll-tree.js.Без названия"></script>
        <script src="./List of metrics - SQL Monitor 9 - Product Documentation_files/jquery.toc-1.1.4.js.Без названия"></script>
        <script src="./List of metrics - SQL Monitor 9 - Product Documentation_files/jquery.fancybox.pack.js.Без названия"></script>
        <script src="./List of metrics - SQL Monitor 9 - Product Documentation_files/jquery.tabs.js.Без названия"></script>
		<script>window.Honeycomb = window.Honeycomb || {}; window.Honeycomb.path='';</script>
        <script src="./List of metrics - SQL Monitor 9 - Product Documentation_files/honeycomb.min.js.Без названия"></script>
		<script src="./List of metrics - SQL Monitor 9 - Product Documentation_files/redgate.confluence.js.Без названия"></script>
		<script src="./List of metrics - SQL Monitor 9 - Product Documentation_files/documentation.js.Без названия"></script>

    <script src="./List of metrics - SQL Monitor 9 - Product Documentation_files/bootstrap.js.Без названия" async=""></script>

<iframe scrolling="no" frameborder="0" allowtransparency="true" src="./List of metrics - SQL Monitor 9 - Product Documentation_files/widget_iframe.4f8aea4342a4ada72cba2bdffcff6b4d.html" title="Twitter settings iframe" style="display: none;"></iframe></body></html>